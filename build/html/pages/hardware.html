

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Hardware &mdash; SIAT  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SIAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">MEISHAV100:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="start.html">1. START</a></li>
<li class="toctree-l1"><a class="reference internal" href="hardware/index.html">2. Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="fpga.html">3. Prototype Verificaton On FPGA</a></li>
<li class="toctree-l1"><a class="reference internal" href="backend.html">4 Backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="device.html">5. DEVICE(SD)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SIAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">2. Hardware</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/pages/hardware.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="hardware">
<h1>2. Hardware<a class="headerlink" href="#hardware" title="Link to this heading"></a></h1>
<p><img alt="alt text" src="../_images/image-26.png" /></p>
<div align=center> 
Completion 
<div>     <div align=left> 
<div>    <p>The table below provides a list of the hardware modules we currently possess:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Design</th>
<th style="text-align: center;">Spec Version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GPIO</td>
<td style="text-align: center;">1.1.0</td>
</tr>
<tr>
<td style="text-align: center;">SPI</td>
<td style="text-align: center;">1.1.0</td>
</tr>
<tr>
<td style="text-align: center;">QSPI</td>
<td style="text-align: center;">1.1.0</td>
</tr>
<tr>
<td style="text-align: center;">UART</td>
<td style="text-align: center;">1.1.0</td>
</tr>
<tr>
<td style="text-align: center;">JTAG</td>
<td style="text-align: center;">1.1.0</td>
</tr>
<tr>
<td style="text-align: center;">SRAM</td>
<td style="text-align: center;">1.1.0</td>
</tr>
</tbody>
</table><ul class="simple">
<li><p>The chip incorporates GPIO peripherals, which facilitate bidirectional communication with the external environment.</p></li>
<li><p>The chip features two SPIs and one QSPI, supporting both single-wire and four-wire modes, and is employed for communication with external devices, such as SD cards.</p></li>
<li><p>The chip includes a UART peripheral, which implements dual-lane full-duplex UART functionality.</p></li>
<li><p>The chip houses a JTAG port. By interfacing with the JTAG pins, the logic within the debug module enables the core to enter debug mode, affording the ability to inject code either into the device—through instruction emulation—or directly into memory.</p></li>
</ul>
<section id="gpio">
<h2>2.1 GPIO<a class="headerlink" href="#gpio" title="Link to this heading"></a></h2>
<section id="gpio-technical-specification">
<h3>2.1.1 GPIO Technical Specification<a class="headerlink" href="#gpio-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-20.png" /></p>
<section id="description">
<h4>Description<a class="headerlink" href="#description" title="Link to this heading"></a></h4>
<p>The GPIO module facilitates software communication through general-purpose I/O pins with a high degree of flexibility. Each of the 32 individual bits can be configured as peripheral outputs using two distinct modes. Similarly, each of these 32 bits can be accessed by software as peripheral inputs. The connectivity of these peripheral inputs and outputs to the chip’s I/O pins is beyond the scope of this document. Refer to the Comportability Specification for detailed peripheral I/O options at the top chip level.</p>
<p>In the output configuration, this module offers direct 32-bit access to each GPIO value via direct write functionality. This mode empowers software to control all GPIO bits simultaneously. Alternatively, the module supports masked writes, which allow software to update half of the bits at once, enabling the modification of a subset of the output values without necessitating a read-modify-write sequence. In this mode, the user specifies a mask indicating which of the 16 bits are to be altered, along with their new values. Detailed operation of this mode is elucidated in the Programmers Guide.</p>
<p>For input operations, software can read the status of any GPIO peripheral input. Additionally, software can configure interrupt events for any of the 32 bits, with options including positive edge, negative edge, or level detection. A noise filter can be enabled for any of the 32 GPIO inputs, requiring the input to remain stable for 16 module clock cycles before the input register acknowledges the change and evaluates interrupt generation. It is important to note that if the filter is activated and the pin is designated as an output, there will be a corresponding delay in reflecting output changes in the input register.</p>
<p>For in-depth insights into output, input, and interrupt control mechanisms, please consult the Design Details section.</p>
</section>
<section id="features">
<h4>Features<a class="headerlink" href="#features" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>32 General Purpose Input/Output (GPIO) ports</p></li>
<li><p>Configurable interrupt capability for each GPIO, supporting rising edge, falling edge, or active low/high input detection</p></li>
<li><p>Dual methods for updating GPIO output: direct write and masked (thread-safe) update</p></li>
</ul>
</section>
</section>
<section id="theory-of-operation">
<h3>2.1.2 Theory of Operation<a class="headerlink" href="#theory-of-operation" title="Link to this heading"></a></h3>
<section id="gpio-output">
<h4>GPIO Output<a class="headerlink" href="#gpio-output" title="Link to this heading"></a></h4>
<p>The GPIO module maintains a single 32-bit output register, DATA_OUT, with two methods of write access. Direct write access utilizes DIRECT_OUT, while masked write access employs MASKED_OUT_UPPER and</p>
<p>MASKED_OUT_LOWER. Direct access allows full read and write capabilities for all 32 bits within one register.</p>
<p>For masked access, the bits to be modified are specified as a mask in the upper 16 bits of the MASKED_OUT_UPPER and MASKED_OUT_LOWER register writes, with the data to be written provided in the lower 16 bits of the register write. The hardware updates DATA_OUT according to this mask, enabling modifications without requiring software to perform a Read-Modify-Write operation.</p>
<p>Reads from masked registers return the lower or upper 16 bits of the DATA_OUT contents, with zeros returned in the upper 16 bits (mask field). To read the values on the pins, software should access the DATA_IN register. (Refer to the GPIO Input section below).</p>
<p>This same concept is applied to the output enable register, DATA_OE. Direct access uses DIRECT_OE, and masked access is facilitated through MASKED_OE_UPPER and MASKED_OE_LOWER. The output enable is transmitted to the pad control block to determine whether the pad should drive the DATA_OUT value to the associated pin.</p>
<p>A typical usage pattern involves initializing and suspending/resuming code utilizing the full access registers to set the output enables and current output values, before switching to masked access for both DATA_OUT and DATA_OE.</p>
<p>For GPIO outputs that are not in use (either not connected to a pin output or not selected for pin multiplexing), the output values are disconnected and have no impact on the GPIO input, regardless of the output enable settings.</p>
</section>
<section id="gpio-input">
<h4>GPIO Input<a class="headerlink" href="#gpio-input" title="Link to this heading"></a></h4>
<p>The DATA_IN register provides the contents as observed on the peripheral input, usually from the pads connected to these inputs. In the presence of a pin-multiplexing unit, GPIO peripheral inputs not connected to a chip input will be tied to a constant zero input.</p>
<p>The GPIO module offers optional independent noise filter control for each of the 32 input signals. Each input can be independently enabled with the CTRL_EN_INPUT_FILTER (one bit per input). This 16-cycle filter is applied to both the DATA_IN register and the interrupt detection logic. The timing for DATA_IN remains non-instantaneous if CTRL_EN_INPUT_FILTER is false due to top-level routing, but no flops are present between the chip input and the DATA_IN register.</p>
<p>The contents of DATA_IN are always readable and reflect the value seen at the chip input pad, irrespective of the output enable setting from DATA_OE. If the output enable is true (and the GPIO is connected to a chip-level pad), the value read from DATA_IN includes the effect of the peripheral’s driven output (thus differing from DATA_OUT only if the output driver is unable to switch the pin or during the delay imposed if the noise filter is enabled).</p>
</section>
<section id="interrupts">
<h4>Interrupts<a class="headerlink" href="#interrupts" title="Link to this heading"></a></h4>
<p>The GPIO module provides 32 interrupt signals to the main processor. Each interrupt can be independently enabled, tested, and configured. Following the standard interrupt guidelines in the Comportability Specification, the 32 bits of the INTR_ENABLE register determine whether the associated inputs are configured to detect interrupt events. If enabled via the various INTR_CTRL_EN registers, their current state can be read in the INTR_STATE register. Clearing is achieved by writing a 1 into the associated INTR_STATE bit field.</p>
<p>For configuration, four types of interrupts are available per bit, controlled with four control registers. INTR_CTRL_EN_RISING configures the associated input for rising-edge detection. Similarly, INTR_CTRL_EN_FALLING detects falling edge inputs. INTR_CTRL_EN_LVLHIGH and INTR_CTRL_EN_LVLLOW allow the input to be level-sensitive interrupts. Theoretically, an input can be configured to detect both rising and falling edges, but there is no hardware assistance to indicate which edge caused the output interrupt.</p>
<p><strong>Note #1</strong>: The interrupt can only be triggered by GPIO input. <strong>Note #2</strong>: All inputs are subject to optional noise filtering before being sent into interrupt detection. <strong>Note #3</strong>: All interrupts to the processor are level interrupts as per the Comportability Specification guidelines. The GPIO module, if configured, converts an edge detection into a level interrupt to the processor core.</p>
</section>
</section>
</section>
<section id="uart">
<h2>2.2 UART<a class="headerlink" href="#uart" title="Link to this heading"></a></h2>
<section id="uart-technical-specification">
<h3>2.2.1 UART Technical Specification<a class="headerlink" href="#uart-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-21.png" /></p>
<section id="id1">
<h4>Description<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<p>UART is a universal serial data bus designed for asynchronous communication. The bidirectional nature of the bus facilitates full-duplex transmission and reception. UART operates by transmitting data bits one by one. Typically, three wires are utilised to complete the communication: the transmission line (TX), the reception line (RX), and the ground line (GND). The TX and RX of both parties must be cross-connected, while the GND can be connected for normal communication.</p>
</section>
<section id="id2">
<h4>Features<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>2-pin full-duplex external interfaces</p></li>
<li><p>8-bit data word, optional even or odd parity bit per byte</p></li>
<li><p>1 stop bit</p></li>
<li><p><font color=black>32 x 8b RX buffer </font></p></li>
<li><p><font color=black>32 x 8b TX buffer </font></p></li>
<li><p>Programmable baud rate</p></li>
</ul>
</section>
</section>
<section id="id3">
<h3>2.2.2 Theory of Operation<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<section id="communication-protoco">
<h4>Communication Protoco<a class="headerlink" href="#communication-protoco" title="Link to this heading"></a></h4>
<p>During idle periods, the TX/RX serial lines maintain a high state. Data transmission commences with a START bit, when the high idle state transitions from 1 to 0, followed by 8 data bits. The least significant bit is transmitted first. If the parity feature is enabled, an odd or even parity bit is inserted after the data bits. Conclusively, a STOP bit, maintained at logic 1, signifies the completion of one byte of data transfer.</p>
<p><img alt="alt text" src="../_images/image-27.png" /></p>
<div>  
<div align=center><div>   
UART Communication Frame  <div>
<div align=left><div>    </section>
<section id="transmission">
<h4>Transmission<a class="headerlink" href="#transmission" title="Link to this heading"></a></h4>
<p>Writing to <code class="docutils literal notranslate"><span class="pre">WDATA</span></code>register enqueues a data byte into the 32-byte deep write FIFO, thereby triggering the transmit module to initiate UART TX serial data transfer. The TX module dequeues the byte from the FIFO and shifts it bit by bit onto the UART TX pin on the positive edges of the baud clock.</p>
<p>In the event that TX is not enabled, data written into the FIFO will be accumulated and transmitted once TX is enabled.</p>
<p>Upon the FIFO becoming empty as part of the transmission process, a TX FIFO done interrupt will be generated when the final byte has completed transmission. This interrupt is distinct from the TX FIFO watermark interrupt.</p>
</section>
<section id="reception">
<h4>Reception<a class="headerlink" href="#reception" title="Link to this heading"></a></h4>
<p>The RX module oversamples the RX input pin at 16 times the requested baud rate. Upon detecting a low state on the input, the receiver verifies that the line remains low half a bit-time later  to confirm the START bit. If the line returns to a high state, the potential glitch is disregarded. After identifying the START bit, the RX module samples at the center of each bit-time, collecting incoming serial bits into a character buffer. If the STOP bit is detected as high and the optional parity bit is correct, the data byte is enqueued into the 32-byte deep RX FIFO. The data can then be retrieved by reading the <code class="docutils literal notranslate"><span class="pre">RDATA</span></code> register.</p>
</section>
</section>
<section id="design-verification">
<h3>2.2.3 Design Verification<a class="headerlink" href="#design-verification" title="Link to this heading"></a></h3>
<p><strong>Goals</strong></p>
<p>Verify UART IP features by running dynamic simulations with a SV/UVM based testbench</p>
<p><strong>Design features</strong></p>
<p>For detailed information on UART design features, please see the <strong>UART Technical Specification</strong>.</p>
<p><strong>Testbench architecture</strong></p>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>UART IOs</p></li>
</ul>
<p><strong>Global types &amp; methods</strong></p>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">uart_env_pkg</span></code></p>
<p><strong>TL_agent</strong></p>
<p>UART instantiates <code class="docutils literal notranslate"><span class="pre">tl_agent</span></code> which provides the ability to drive and independently monitor random traffic via TL host interface into UART device.</p>
<p><strong>UART_agent</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">UART</span> <span class="pre">agent</span></code> is used to drive and monitor UART items, which also provides basic coverage on data, parity, baud rate etc. These baud rates are supported: 9600, 115200, 230400, 1Mbps(1048576), 2Mbps(2097152)</p>
</section>
<section id="testplan">
<h3>2.2.3.1 Testplan<a class="headerlink" href="#testplan" title="Link to this heading"></a></h3>
<p>This validation environment encompasses a substantial amount of supplementary code; however, the parent classes may introduce anomalies or superfluous functionalities. Consequently, it is permissible to directly alter the inherited parent class to the corresponding UVM base class, as necessitated</p>
<section id="develop-an-agent">
<h4>2.2.3.1.1 Develop an agent<a class="headerlink" href="#develop-an-agent" title="Link to this heading"></a></h4>
<p>In the environment written this time, <code class="docutils literal notranslate"><span class="pre">uart</span></code>, as <code class="docutils literal notranslate"><span class="pre">slave_agent</span></code>, is driven by soc, so uart_agent only contains a driver, which is used to collect signals from the uart port during the test.</p>
<section id="uart-agent-cfg-sv">
<h5>uart_agent_cfg.sv<a class="headerlink" href="#uart-agent-cfg-sv" title="Link to this heading"></a></h5>
<p>The baud rate, parity check bit and other attributes of uart are defined, and a uart interface is declared for monitor to collect data. There are 7 functions in this file, which are:<code class="docutils literal notranslate"><span class="pre">set_uart_period_glitch_pct、get_uart_period_glitch_pct、set_baud_rate、set_parity、set_max_drift_cycle_pct、get_max_drift_cycle_pct、reset_asserted、reset_deasserted</span></code>.</p>
</section>
<section id="uart-agent-pkg-sv">
<h5>uart_agent_pkg.sv<a class="headerlink" href="#uart-agent-pkg-sv" title="Link to this heading"></a></h5>
<p>The library and files used by uart_agent are imported, and some enumerated variables are defined, such as BaudRate(baud rate), transmission direction (single, dual, quad), etc., which is convenient for us to use.</p>
</section>
<section id="uart-agent-sv">
<h5>uart_agent.sv<a class="headerlink" href="#uart-agent-sv" title="Link to this heading"></a></h5>
<p>A <code class="docutils literal notranslate"><span class="pre">uart_monitor</span></code> and <code class="docutils literal notranslate"><span class="pre">uart_agent_config</span></code> are defined, <code class="docutils literal notranslate"><span class="pre">uart_if</span></code> as set in <code class="docutils literal notranslate"><span class="pre">config_db</span></code> is passed to<code class="docutils literal notranslate"> <span class="pre">cfg.uart_if</span></code>, and <code class="docutils literal notranslate"><span class="pre">uart_cfg</span></code> is set to the database.</p>
</section>
<section id="uart-driver-sv">
<h5>uart_driver.sv<a class="headerlink" href="#uart-driver-sv" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">uart_driver</span></code> class inherits from <code class="docutils literal notranslate"><span class="pre">dv_base_driver</span></code> and is used to drive transmission and receive operations in the simulation environment of UART. It is responsible for getting the data item <code class="docutils literal notranslate"><span class="pre">uart_item</span></code> from the sequencer and driving it to the UART interface. This class mainly simulates the receiving process of data by controlling the received signal of the UART interface<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>.</p>
</section>
<section id="main-tasks-and-functions">
<h5>Main tasks and functions:<a class="headerlink" href="#main-tasks-and-functions" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">run_phase</span></code>:<br /><code class="docutils literal notranslate"><span class="pre">run_phase</span></code> is one of the UVM simulation phases, in which the driver first calls the <code class="docutils literal notranslate"><span class="pre">reset_signals</span></code> method to reset the UART interface signal, and then enters the<code class="docutils literal notranslate"> <span class="pre">get_and_drive</span></code>task, continuously fetching data from the sequencer and driving the transmission.</p>
<p><code class="docutils literal notranslate"><span class="pre">reset_signals</span></code>:<br />This task is used to reset the UART received signal (’ uart_rx ‘) to ensure that the signal is in a known state at the start of the simulation.
<code class="docutils literal notranslate"><span class="pre">set_rx</span></code> :
The <code class="docutils literal notranslate"><span class="pre">set_rx</span></code> task is responsible for setting the value of the received signal (<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>) of the UART, while randomly introducing some small amplitude signal failures (usually 10% of the clock cycle) according to the configuration. This function is used to simulate the signal jitter and faults that may exist in real hardware, so as to test the fault tolerance of the system to these abnormal conditions.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_and_drive</span></code>:<br />This task takes the data item (<code class="docutils literal notranslate"><span class="pre">uart_item</span></code>) from the sequencer (<code class="docutils literal notranslate"><span class="pre">seq_item_port</span></code>) and drives it to the UART interface based on the information in the configuration and request.<br />If parity is enabled (<code class="docutils literal notranslate"><span class="pre">en_parity</span></code>) or the parity configuration is overridden in the request (<code class="docutils literal notranslate"> <span class="pre">ovrd_en_parity</span></code>), it transmits all data bits including the parity bits to the ‘uart_rx’ signal.
This task also handles the situation during a reset, and if a reset signal is detected, the currently transmitted data item is abandoned.</p>
<p><code class="docutils literal notranslate"><span class="pre">wait_uart_rx_cycle</span></code>:<br />The <code class="docutils literal notranslate"><span class="pre">wait_uart_rx_cycle</span></code> task is used to wait for the next clock cycle when the UART receives a signal. This can be done by waiting for the callback function (<code class="docutils literal notranslate"><span class="pre">drv_rx_cb</span></code>) in the simulation environment or by detecting the reset signal.
The task monitors the reset signal or UART clock event through the <code class="docutils literal notranslate"><span class="pre">fork</span></code> mechanism and chooses to end the current cycle based on the simulation.</p>
</section>
<section id="uart-if-sv">
<h5>uart_if.sv<a class="headerlink" href="#uart-if-sv" title="Link to this heading"></a></h5>
<p>The uart interface provides data for the monitor. Contains the 2 basic signals of uart and some signals for debugging.</p>
</section>
<section id="uart-item-sv">
<h5>uart_item.sv<a class="headerlink" href="#uart-item-sv" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">uart_item</span></code> class is a UVM class that inherits from <code class="docutils literal notranslate"><span class="pre">uvm_sequence_item</span></code> and represents the basic data unit that is transferred in UART communication. This class defines the basic structure of a UART packet, including the start bit, stop bit, data, parity and other information, and provides some constraints and methods to control the randomization and use of these fields.</p>
</section>
<section id="uart-monitor-sv">
<h5>uart_monitor.sv<a class="headerlink" href="#uart-monitor-sv" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">tx_analysis_port</span></code>and <code class="docutils literal notranslate"><span class="pre">rx_analysis_port</span></code> are used to collect data transmitted and received by the UART respectively and to pass this data to the <code class="docutils literal notranslate"><span class="pre">scoreboard</span></code> for further analysis and verification.</p>
</section>
<section id="id4">
<h5>Main tasks and functions:<a class="headerlink" href="#id4" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">collect_tx_data</span></code>：<br />This task monitors the UART transmission signal (<code class="docutils literal notranslate"><span class="pre">uart_tx</span> </code>) and collects data for each transmission. When <code class="docutils literal notranslate"><span class="pre">uart_tx</span></code> is low and <code class="docutils literal notranslate"><span class="pre">tx_monitor</span></code> is enabled, the data collection process begins.</p>
<p>The collection process consists of getting the start bit, the data bit, the check bit (if enabled), and finally the stop bit. Each bit is collected via a callback function of the monitor interface.
After the collection is complete, the task checks whether the check bit is correct and passes the collected data to the tx_analysis_port for further analysis by the scoreboard.</p>
<p><code class="docutils literal notranslate"><span class="pre">collect_rx_data</span></code>：<br />This task monitors the UART reception signal (<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>) and collects data on each reception. Similar to the <code class="docutils literal notranslate"><span class="pre">collect_tx_data</span></code>task, data collection begins when <code class="docutils literal notranslate"><span class="pre">uart_rx</span></code> is low and <code class="docutils literal notranslate"><span class="pre">rx_monitor</span></code> is enabled.<br />The collection process consists of getting the start bit, the data bit, the check bit (if enabled), and finally the stop bit. The collection of each bit is also done through the callback function of the monitor interface.<br />After the collection is complete, the task checks whether the check bit is correct and passes the collected data to the rx_analysis_port for further analysis by the scoreboard.<br /><code class="docutils literal notranslate"><span class="pre">drive_tx_clk</span></code> and <code class="docutils literal notranslate"><span class="pre">drive_rx_clk</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">drive_tx_clk</span></code>and<code class="docutils literal notranslate"><span class="pre">drive_rx_clk</span></code>are used to drive the transmission and reception of the clock signal of the UART, respectively, to ensure that the data is collected within the correct clock cycle.</p>
<p><code class="docutils literal notranslate"><span class="pre">mon_tx_stable</span></code>:<br />The <code class="docutils literal notranslate"><span class="pre">mon_tx_stable</span></code> task is responsible for monitoring the stability of the UART transmitted signal and checking whether the signal remains stable for a specified clock period.</p>
<p><code class="docutils literal notranslate"><span class="pre">process_reset</span></code>:<br /><code class="docutils literal notranslate"><span class="pre">process_reset</span></code> are used to reset the UART. During the reset, data collection is stopped. After the reset is complete, the data collection process is restarted.</p>
</section>
<section id="uart-logger-sv">
<h5>uart_logger.sv<a class="headerlink" href="#uart-logger-sv" title="Link to this heading"></a></h5>
<p>The uart_logger class is a UVM component that inherits from the uvm_component and is used to capture the log data transferred from the UART and store it in a log file or print it in a simulation log.</p>
</section>
<section id="uart-base-agent-core">
<h5>uart_base_agent.core<a class="headerlink" href="#uart-base-agent-core" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">.core</span> </code>file is the configuration file that fusesoc uses to manage the project and can copy other written files and then make changes to several parts.</p>
</section>
</section>
<section id="develop-an-env">
<h4>2.2.3.1.2 Develop an env<a class="headerlink" href="#develop-an-env" title="Link to this heading"></a></h4>
<section id="uart-scoreboard-sv">
<h5>uart_scoreboard.sv<a class="headerlink" href="#uart-scoreboard-sv" title="Link to this heading"></a></h5>
<p>Define four queues to store the expected and actual write data and read data. The expected data is obtained from the tl-agent, and the actual data is obtained from the uart-agent. Retrieve the uart data using <code class="docutils literal notranslate"><span class="pre">uvm_blocking_get_port</span></code> and compare the expected data with the actual data. However, the current scoreboard has some problems and is not used in the current validation environment.</p>
</section>
<section id="uart-env-sv">
<h5>uart_env.sv<a class="headerlink" href="#uart-env-sv" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">uart_agent,</span> <span class="pre">uart_agent_cfg,</span> <span class="pre">uart_scoreboard,</span> <span class="pre">and</span> <span class="pre">uvm_tlm_analysis_fifo</span></code> (connecting uart_scoreboard and uart_monitor) are defined.</p>
</section>
<section id="uart-env-pkg-sv">
<h5>uart_env_pkg.sv<a class="headerlink" href="#uart-env-pkg-sv" title="Link to this heading"></a></h5>
<p>The libraries and files used by uart_env are imported.</p>
</section>
<section id="uart-base-env-core">
<h5>uart_base_env.core<a class="headerlink" href="#uart-base-env-core" title="Link to this heading"></a></h5>
<p>The configuration file for uart_env, which provides dependencies for uart_test.</p>
</section>
</section>
<section id="develop-an-sequence">
<h4>2.2.3.1.3 Develop an sequence<a class="headerlink" href="#develop-an-sequence" title="Link to this heading"></a></h4>
<section id="seq-lib-sv">
<h5>seq_lib.sv<a class="headerlink" href="#seq-lib-sv" title="Link to this heading"></a></h5>
<p>Base sequence of uart. The current environment uses uart_item in the agent folder that is the same as this sequence. Therefore, this file is not used currently.</p>
</section>
</section>
<section id="develop-an-test">
<h4>2.2.3.1.4 Develop an test<a class="headerlink" href="#develop-an-test" title="Link to this heading"></a></h4>
<section id="uart-test-sv">
<h5>uart_test.sv<a class="headerlink" href="#uart-test-sv" title="Link to this heading"></a></h5>
<p>The test is modified by referring to the tl-test written in the environment.</p>
</section>
<section id="uart-macros-svh">
<h5>uart_macros.svh<a class="headerlink" href="#uart-macros-svh" title="Link to this heading"></a></h5>
<p>The register base address and offset of uart are defined for our convenience.</p>
</section>
<section id="uart-test-v">
<h5>uart_test.v<a class="headerlink" href="#uart-test-v" title="Link to this heading"></a></h5>
<p>Refer to <code class="docutils literal notranslate"><span class="pre">tlul_test.sv</span></code> to write, mainly to change the <code class="docutils literal notranslate"><span class="pre">main_phase</span></code> code. The rest just defines a <code class="docutils literal notranslate"><span class="pre">uart_if</span></code> in <code class="docutils literal notranslate"><span class="pre">uart_base_test_cfg</span></code> and a <code class="docutils literal notranslate"><span class="pre">uart_env</span></code> in <code class="docutils literal notranslate"><span class="pre">uart_base_test</span></code>.</p>
</section>
<section id="uart-interface-definition">
<h5>UART interface definition：<a class="headerlink" href="#uart-interface-definition" title="Link to this heading"></a></h5>
<p>The uart_if interface is defined in the <code class="docutils literal notranslate"><span class="pre">uart_base_test_cfg</span></code> for communicating with the UART environment.<br />The UART environment is initialized：<br />Initialize the <code class="docutils literal notranslate"><span class="pre">uart_env</span></code> environment in uart_base_test, which is responsible for configuring and monitoring the behavior of the UART.</p>
</section>
<section id="register-configuration">
<h5>Register configuration：<a class="headerlink" href="#register-configuration" title="Link to this heading"></a></h5>
<p>In <code class="docutils literal notranslate"><span class="pre">main_phase</span></code>, data is written to the register of the UART mainly through the TileLink (TL) protocol agent (<code class="docutils literal notranslate"><span class="pre">TL-agent</span> </code>) to complete the register configuration. Compared with the Register Abstraction layer (RAL), TL-agent can interact with hardware more directly and is suitable for lower-level verification scenarios.</p>
<p>Use TL-agent to configure UART control registers, including <code class="docutils literal notranslate"><span class="pre">DIV</span></code>, <code class="docutils literal notranslate"><span class="pre">TXCTRL</span></code>, <code class="docutils literal notranslate"><span class="pre">RXCTRL</span></code> and so on.
After the configuration, the TL-agent writes the generated data to <code class="docutils literal notranslate"><span class="pre">uart_txfifo</span></code>.</p>
</section>
</section>
</section>
<section id="hardware-interfaces">
<h3>2.2.4 Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Link to this heading"></a></h3>
<p>The following table shows the uart connection method:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Master_Port</th>
<th style="text-align: center;">Slave_Port</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Master_Tx</td>
<td style="text-align: center;">Slave_Rx</td>
</tr>
<tr>
<td style="text-align: center;">Master_Rx</td>
<td style="text-align: center;">Slave_Tx</td>
</tr>
<tr>
<td style="text-align: center;">GND</td>
<td style="text-align: center;">GND</td>
</tr>
</tbody>
</table><p>The following diagram shows the system block diagram of UART：</p>
<div align=center>    <p><img alt="alt text" src="../_images/image-6.png" /></p>
<p>Block Diagram</p>
<div>
<div align=left><div>   </section>
<section id="registers">
<h3>2.2.5 Registers<a class="headerlink" href="#registers" title="Link to this heading"></a></h3>
<section id="control-register">
<h4>Control Register<a class="headerlink" href="#control-register" title="Link to this heading"></a></h4>
<p>A serial port control register is a specialized type of register within communication interfaces, responsible for managing the configuration and control of serial communication lines. These registers are essential for facilitating and overseeing data transfers between devices that employ serial communication protocols.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">offset</th>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">txdata</td>
<td style="text-align: center;">Transmit data register</td>
</tr>
<tr>
<td style="text-align: center;">0x04</td>
<td style="text-align: center;">rxdata</td>
<td style="text-align: center;">Receiver data register</td>
</tr>
<tr>
<td style="text-align: center;">0x08</td>
<td style="text-align: center;">txctrl</td>
<td style="text-align: center;">Transmit control register</td>
</tr>
<tr>
<td style="text-align: center;">0x0C</td>
<td style="text-align: center;">rxctrl</td>
<td style="text-align: center;">Receive control register</td>
</tr>
<tr>
<td style="text-align: center;">0X10</td>
<td style="text-align: center;">ie</td>
<td style="text-align: center;">UART interrupt enable</td>
</tr>
<tr>
<td style="text-align: center;">0X14</td>
<td style="text-align: center;">ip</td>
<td style="text-align: center;">UART interrupt pending</td>
</tr>
<tr>
<td style="text-align: center;">0X18</td>
<td style="text-align: center;">div</td>
<td style="text-align: center;">Baud rate divisor</td>
</tr>
</tbody>
</table><p>The functions typically managed by these registers include:</p>
</section>
<section id="baud-rate-divisor-register-div">
<h4>Baud Rate Divisor Register(div)<a class="headerlink" href="#baud-rate-divisor-register-div" title="Link to this heading"></a></h4>
<p>It determines the speed of data transmission in bits per second (baud). The div register designates the divisor employed for the baud rate generation of the Tx and Rx channels. The input clock is derived from the bus clock. The reset value of the register is configured to div_init, and, given the anticipated frequency of the tlclk, it is calibrated to yield a 115200 baud output upon reset.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">tlclk (MHz)</th>
<th style="text-align: center;">Target Baud (Hz)</th>
<th style="text-align: center;">Divisor</th>
<th style="text-align: center;">Actual Baud (Hz)</th>
<th style="text-align: center;">Error (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">500</td>
<td style="text-align: center;">31250</td>
<td style="text-align: center;">16000</td>
<td style="text-align: center;">31250</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">500</td>
<td style="text-align: center;">115200</td>
<td style="text-align: center;">4340</td>
<td style="text-align: center;">115207</td>
<td style="text-align: center;">0.0064</td>
</tr>
<tr>
<td style="text-align: center;">500</td>
<td style="text-align: center;">250000</td>
<td style="text-align: center;">2000</td>
<td style="text-align: center;">250000</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">500</td>
<td style="text-align: center;">1843200</td>
<td style="text-align: center;">271</td>
<td style="text-align: center;">1845018</td>
<td style="text-align: center;">0.099</td>
</tr>
<tr>
<td style="text-align: center;">750</td>
<td style="text-align: center;">31250</td>
<td style="text-align: center;">24000</td>
<td style="text-align: center;">31250</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">750</td>
<td style="text-align: center;">115200</td>
<td style="text-align: center;">6510</td>
<td style="text-align: center;">6510</td>
<td style="text-align: center;">0.0064</td>
</tr>
<tr>
<td style="text-align: center;">750</td>
<td style="text-align: center;">250000</td>
<td style="text-align: center;">3000</td>
<td style="text-align: center;">3000</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">750</td>
<td style="text-align: center;">1843200</td>
<td style="text-align: center;">407</td>
<td style="text-align: center;">407</td>
<td style="text-align: center;">0.024</td>
</tr>
</tbody>
</table></section>
<section id="transmit-data-register-txdata">
<h4>Transmit Data Register (txdata)<a class="headerlink" href="#transmit-data-register-txdata" title="Link to this heading"></a></h4>
<p>If the FIFO is capable of accepting a new entry, then writing to the txdata register queues the characters contained within the data field to the transmitting FIFO. Reading from txdata returns the current value of the full flag and sets the data field to zero. The full flag signifies whether the transmitting FIFO can accommodate the new entry. Post-setting, writes to the data field are disregarded.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;"><strong>Bits</strong></th>
<th style="text-align: center;"><strong>Field Name</strong></th>
<th style="text-align: center;"><strong>Attr.</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">data</td>
<td style="text-align: center;">RW</td>
</tr>
<tr>
<td style="text-align: center;">[30:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">31</td>
<td style="text-align: center;">full</td>
<td style="text-align: center;">RO</td>
</tr>
</tbody>
</table></section>
<section id="receive-data-register-rxdata">
<h4>Receive Data Register (rxdata)<a class="headerlink" href="#receive-data-register-rxdata" title="Link to this heading"></a></h4>
<p>The read rxdata register extracts a character from the received FIFO and returns its value in the data field. The empty flag indicates whether the received FIFO is devoid of contents. Upon being set, the data field does not contain valid characters. Writes to rxdata are ignored.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;"><strong>Bits</strong></th>
<th style="text-align: center;"><strong>Field Name</strong></th>
<th style="text-align: center;"><strong>Attr.</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">data</td>
<td style="text-align: center;">RW</td>
</tr>
<tr>
<td style="text-align: center;">[30:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">31</td>
<td style="text-align: center;">full</td>
<td style="text-align: center;">RO</td>
</tr>
</tbody>
</table></section>
<section id="interrupt-registers-ip-and-ie">
<h4>Interrupt Registers (ip and ie)<a class="headerlink" href="#interrupt-registers-ip-and-ie" title="Link to this heading"></a></h4>
<p>The ip register is a read-only register that indicates pending interrupt conditions, while the read-write ie register controls which UART interrupts are enabled. ie was reset to 0.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;"><strong>Bits</strong></th>
<th style="text-align: center;"><strong>Field Name</strong></th>
<th style="text-align: center;"><strong>Attr.</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">txwm</td>
<td style="text-align: center;">RW</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">rxwm</td>
<td style="text-align: center;">RW</td>
</tr>
<tr>
<td style="text-align: center;">[31:2]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
</section>
<section id="checklist">
<h3>2.2.6 Checklist<a class="headerlink" href="#checklist" title="Link to this heading"></a></h3>
<section id="design-checklist">
<h4>Design Checklist<a class="headerlink" href="#design-checklist" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Item</th>
<th style="text-align: center;">Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Documentation</td>
<td style="text-align: center;">UART SPEC</td>
<td style="text-align: center;">Done</td>
</tr>
<tr>
<td style="text-align: center;">RTL</td>
<td style="text-align: center;">Design</td>
<td style="text-align: center;">Done</td>
</tr>
</tbody>
</table></section>
<section id="verification-checklist">
<h4>Verification Checklist<a class="headerlink" href="#verification-checklist" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Item</th>
<th style="text-align: center;">Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Documentation</td>
<td style="text-align: center;">VIP</td>
<td style="text-align: center;">Done</td>
</tr>
<tr>
<td style="text-align: center;">RTL</td>
<td style="text-align: center;">Design</td>
<td style="text-align: center;">Done</td>
</tr>
</tbody>
</table></section>
</section>
</section>
<section id="spi">
<h2>2.3 SPI<a class="headerlink" href="#spi" title="Link to this heading"></a></h2>
<section id="spi-technical-specification">
<h3>2.3.1 SPI Technical Specification<a class="headerlink" href="#spi-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-25.png" /></p>
<section id="id5">
<h4>Description<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<p>The SPI controller supports single-, dual-, and quad-channel protocols in host-only mode. The baseline controller provides a FIFO-based interface for executing programmed input/output operations. Software initiates transfers by queuing frames into the transmit FIFO; upon completion, the slave responses are placed in the receive FIFO.</p>
<p>Additionally, the dedicated SPI0 controller implements an SPI flash read sequencer, which exposes the contents of an external SPI flash as a read-only/execute memory-mapped device. Given an input clock rate below 100 MHz and assuming the external SPI flash device supports the common Winbond/Numonyx serial read (0x03) command, the SPI0 controller resets to a state that allows memory-mapped reads. To enhance performance, consecutive accesses are automatically merged into a single long read command.</p>
<p>The fctrl register governs the toggling between memory-mapped and programmed I/O modes. In programmed I/O mode, memory-mapped reads do not access the external SPI flash device and instead return 0 immediately. Hardware interlocks ensure that the current transfer completes before mode transitions and control register updates take effect.</p>
</section>
</section>
<section id="id6">
<h3>2.3.2 Design Verification<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<section id="goals">
<h4>Goals<a class="headerlink" href="#goals" title="Link to this heading"></a></h4>
<section id="dv">
<h5>DV<a class="headerlink" href="#dv" title="Link to this heading"></a></h5>
<p>Verify SPI IP features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="design-features">
<h4>Design features<a class="headerlink" href="#design-features" title="Link to this heading"></a></h4>
<p>For detailed information on SPI design features, please see the <strong>SPI Technical Specification</strong>.</p>
</section>
<section id="testbench-architecture">
<h4>Testbench architecture<a class="headerlink" href="#testbench-architecture" title="Link to this heading"></a></h4>
<section id="top-level-testbench">
<h5>Top level testbench<a class="headerlink" href="#top-level-testbench" title="Link to this heading"></a></h5>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>SPI IOs</p></li>
</ul>
</section>
</section>
<section id="global-types-methods">
<h4>Global types &amp; methods<a class="headerlink" href="#global-types-methods" title="Link to this heading"></a></h4>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">spi_env_pkg</span></code></p>
</section>
<section id="tl-agent">
<h4>TL_agent<a class="headerlink" href="#tl-agent" title="Link to this heading"></a></h4>
<p>SPI Device instantiates (already handled in CIP base env) tl_agent which provides the ability to drive and independently monitor random traffic via TL host interface into SPI Device.</p>
</section>
<section id="spi-agent">
<h4>SPI_agent<a class="headerlink" href="#spi-agent" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">spi</span> <span class="pre">agent</span></code> is used to drive and monitor SPI items.</p>
</section>
</section>
<section id="id7">
<h3>2.3.2.1 Testplan<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>This validation environment encompasses a substantial amount of supplementary code; however, the parent classes may introduce anomalies or superfluous functionalities. Consequently, it is permissible to directly alter the inherited parent class to the corresponding UVM base class, as necessitated</p>
<section id="id8">
<h4>2.3.2.1.1 Develop an agent<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<p>Within this development environment, the SPI operates as a slave_agent driven by the CPU. Consequently, the SPI_agent comprises a single driver responsible for capturing signals emitted by the SPI ports during the testing process.</p>
<section id="spi-agent-cfg-sv">
<h5>spi_agent_cfg.sv<a class="headerlink" href="#spi-agent-cfg-sv" title="Link to this heading"></a></h5>
<p>This file defines properties such as the SPI polarity, phase, endianness, and declares an SPI interface for the monitor to collect data. The core function, <code class="docutils literal notranslate"><span class="pre">wait_sck_edge</span></code>, is pivotal as it determines the sampling timing based on the SPI’s polarity and phase.</p>
</section>
<section id="spi-agent-cov-sv">
<h5>spi_agent_cov.sv<a class="headerlink" href="#spi-agent-cov-sv" title="Link to this heading"></a></h5>
<p>The coverage-related file is currently empty.</p>
</section>
<section id="spi-agent-pkg-sv">
<h5>spi_agent_pkg.sv<a class="headerlink" href="#spi-agent-pkg-sv" title="Link to this heading"></a></h5>
<p>This file imports the libraries and modules required by the <code class="docutils literal notranslate"><span class="pre">SPI</span> <span class="pre">agent</span></code> and also defines various enumerated variables, such as csmode and transfer modes (single, dual, quad), enhancing convenience for usage.</p>
</section>
<section id="spi-agent-sv">
<h5>spi_agent.sv<a class="headerlink" href="#spi-agent-sv" title="Link to this heading"></a></h5>
<p>This defines an <code class="docutils literal notranslate"><span class="pre">spi_monitor</span></code> and <code class="docutils literal notranslate"><span class="pre">spi_config</span></code>, where the configured spi_if from config_db is passed to <code class="docutils literal notranslate"><span class="pre">spi_cfg</span></code>.<code class="docutils literal notranslate"><span class="pre">spi_if</span></code>. Additionally, spi_cfg is set in the database.</p>
</section>
<section id="spi-device-driver-sv">
<h5>spi_device_driver.sv<a class="headerlink" href="#spi-device-driver-sv" title="Link to this heading"></a></h5>
<p>The slave_spi driver currently remains unused.</p>
</section>
<section id="spi-driver-sv">
<h5>spi_driver.sv<a class="headerlink" href="#spi-driver-sv" title="Link to this heading"></a></h5>
<p>The base class for the spi_driver, from which both the master_spi and slave_spi drivers inherit. It defines two virtual tasks: reset and drive. Subclasses can extend it with additional tasks if neede</p>
</section>
<section id="spi-host-driver-sv">
<h5>spi_host_driver.sv<a class="headerlink" href="#spi-host-driver-sv" title="Link to this heading"></a></h5>
<p>The master_spi driver is currently inactive.</p>
</section>
<section id="spi-if-sv">
<h5>spi_if.sv<a class="headerlink" href="#spi-if-sv" title="Link to this heading"></a></h5>
<p>The SPI interface, designed to supply data to the monitor, encompasses the four fundamental SPI signals along with additional debug signals.</p>
</section>
<section id="spi-item-sv">
<h5>spi_item.sv<a class="headerlink" href="#spi-item-sv" title="Link to this heading"></a></h5>
<p>The data actually transmitted by the spi_sequence entails a queue for storing 8-bit data and the transfer type (either write or read).</p>
</section>
<section id="spi-monitor-sv">
<h5>spi_monitor.sv<a class="headerlink" href="#spi-monitor-sv" title="Link to this heading"></a></h5>
<p>The primary components of this file are the definition of two <code class="docutils literal notranslate"><span class="pre">spi_items</span></code> and two <code class="docutils literal notranslate"><span class="pre">uvm_analysis_ports</span></code>, which collect SPI transmission data and facilitate communication with the scoreboard. The core task, collect_trans, is responsible for gathering SPI transmission data. Given that the SPI chip select (CS) signal is active low, collection commences upon detecting a low state on CS. The process involves waiting for a rising edge (conditional on clock polarity and phase) before sampling the MISO signal for validity and storing it in a predefined array (considering endianness). Additionally, the spi_monitor incorporates rudimentary validation by initializing an incremental variable, exp, and comparing it to each collected 8-bit segment to verify data accuracy. Finally, the received data is transmitted to the host_analysis_port for extraction by the scoreboard.</p>
</section>
<section id="spi-sckmode-c-sv">
<h5>spi_sckmode_c.sv<a class="headerlink" href="#spi-sckmode-c-sv" title="Link to this heading"></a></h5>
<p>It is intended to randomize values within the sckmode, but given the current SPI configuration, it is not feasible to write to the corresponding registers via the bus. Consequently, this file remains inactive for the time being.</p>
</section>
<section id="spi-sequencer-sv">
<h5>spi_sequencer.sv<a class="headerlink" href="#spi-sequencer-sv" title="Link to this heading"></a></h5>
<p>The sequencer, designated for transmitting SPI data, currently remains vacant.</p>
</section>
<section id="spi-base-agent-core">
<h5>spi_base_agent.core<a class="headerlink" href="#spi-base-agent-core" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">.core</span></code> file serves as a configuration management tool for projects in FuseSoC, allowing you to replicate existing configurations and modify their components as needed:</p>
<ul class="simple">
<li><p><strong>name</strong>: Set to “lowrisc:dv:XXX:0.1”, where XXX should be replaced with the corresponding name for your project. This name must align with any references to this configuration within other files.</p></li>
<li><p><strong>depend</strong>: Specify dependencies on other configuration files here, such as an environment dependency on an agent.</p></li>
<li><p><strong>files</strong>: This section lists all files included in the current configuration, encompassing all files from the referenced spi_agent. If file ‘a’ is included in file ‘b’, attribute {is_include_file: true} should be appended to file ‘a’.</p></li>
</ul>
<p>For additional details, consult the official FuseSoC documentation at:</p>
<p><a class="reference external" href="https://fusesoc.readthedocs.io/en/stable/user/build_system/index.html">https://fusesoc.readthedocs.io/en/stable/user/build_system/index.html</a>.</p>
</section>
</section>
<section id="id9">
<h4>2.3.2.1.2 Develop an env<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<section id="spi-scoreboard-sv">
<h5>spi_scoreboard.sv<a class="headerlink" href="#spi-scoreboard-sv" title="Link to this heading"></a></h5>
<p>Four queues are defined to store the expected and actual write and read data. The expected data is sourced from the TL-agent, while the actual data is obtained from the SPI-agent. SPI data is retrieved via uvm_blocking_get_port, and a comparison is made between the expected and actual data. However, there are inherent issues with the current scoreboard, rendering it ineffective in the validation environment used.</p>
</section>
<section id="spi-env-sv">
<h5>spi_env.sv<a class="headerlink" href="#spi-env-sv" title="Link to this heading"></a></h5>
<p>The components include an spi_agent, an spi_agent_cfg, an spi_scoreboard, and a uvm_tlm_analysis_fifo which serves to connect the spi_scoreboard with the spi_monitor.</p>
</section>
<section id="spi-env-pkg-sv">
<h5>spi_env_pkg.sv<a class="headerlink" href="#spi-env-pkg-sv" title="Link to this heading"></a></h5>
<p>The necessary libraries and files for the spi_env are imported, and an enumeration variable, spi_host_intr_e, is defined (currently unused) to facilitate utilization</p>
</section>
<section id="spi-base-env-core">
<h5>spi_base_env.core<a class="headerlink" href="#spi-base-env-core" title="Link to this heading"></a></h5>
<p>The configuration file for the spi_env, designed to provide dependencies for the spi_test.</p>
</section>
</section>
<section id="develop-rals">
<h4>2.3.2.1.3 Develop rals<a class="headerlink" href="#develop-rals" title="Link to this heading"></a></h4>
<p>please translate this passage into more professional English by changing sentence structure,grammactical structure,words,etc</p>
</section>
<section id="develop-rtls">
<h4>2.3.2.1.4 Develop rtls<a class="headerlink" href="#develop-rtls" title="Link to this heading"></a></h4>
<p>To validate SPI read operations, an SPI-slave device was integrated into our SOC, enabling data transmission from the SOC’s SPI interface to the SPI-slave. The objective was to verify whether the SPI-slave could accurately relay the correct values back.</p>
<p>The RTL code for this purpose was sourced from a GitHub project (</p>
<p><a class="reference external" href="https://github.com/SherifMohamed2602/SPI_Interface">https://github.com/SherifMohamed2602/SPI_Interface</a></p>
<p>) authored by Sherif Mohamed. The project includes instructions for running tests, which were successfully validated through experimentation. According to the author’s implementation, the testing protocol involves sending 11-bit data segments. The first bit alters the SPI’s state (e.g., write data, read data, write address). The second and third bits indicate to the SPI-slave’s memory to store or transmit corresponding addresses or data. The remaining eight bits constitute the actual data (address or data) being written. This test case methodology was employed to conduct the SPI read validation.</p>
</section>
<section id="develop-seq-libs">
<h4>2.3.2.1.5 Develop seq_libs<a class="headerlink" href="#develop-seq-libs" title="Link to this heading"></a></h4>
<p>The base sequence for SPI, which is currently not utilized as the current environment employs the spi_item from the identical agent folder.</p>
</section>
<section id="develop-tests">
<h4>2.3.2.1.6 Develop tests<a class="headerlink" href="#develop-tests" title="Link to this heading"></a></h4>
<p>This test is adapted from the pre-existing tl-test within the reference environment.</p>
<section id="spi-macros-svh">
<h5>spi_macros.svh<a class="headerlink" href="#spi-macros-svh" title="Link to this heading"></a></h5>
<p>The base address and offset definitions for SPI registers facilitate efficient usage.</p>
</section>
<section id="spi-test-sv">
<h5>spi_test.sv<a class="headerlink" href="#spi-test-sv" title="Link to this heading"></a></h5>
<p>The test was written with reference to the tlul_test.sv, primarily modifying the code within the main_phase. Additional components include the definition of an spi_if within spi_base_test_cfg and an spi_env within spi_base_test.</p>
<p>Within the main_phase, data is sent to SPI registers via the tl-agent to configure them (as an alternative to the ral method). Data is then transmitted to the spi_txfifo, initiating automatic forwarding by the SPI. Accuracy of the mosi port’s output is verified through monitoring. Given that the txfifo can only transmit one byte of data at a time, test data ranging from 0x00 to 0xff is utilized to ensure comprehensive coverage.</p>
<p>The aforementioned process constitutes the write validation, which involves sending data to the spi_txfifo via the tl-agent and verifying its subsequent transmission. For read validation, an additional slave device is connected to the SOC. Notably, the exposed SD-related interfaces at the topmost level of the SOC correspond to the four standard SPI interfaces, facilitating the connection with the spi-slave.</p>
<p>For read validation, we refer to the original test cases within the spi-slave, which involve sending 11 bits per transaction with varying commands (occupying the first three bits). Due to our SPI’s limitation of transmitting one byte at a time, two data transmissions are required to complete a test. Specifically, data transmitted as A[7:0] and B[7:0] includes command signals in A[6:4], while the actual data consists of {A[3:0], B[7:4]}. Examination of the spi-slave’s RTL or TB files reveals support for four commands, with the “read data” operation requiring a third data transmission (of any value) to ensure complete data return via miso. Additionally, each test involves configuring the csmode register to hold, sending data twice to txfifo, and then disabling csmode. Between tests, an additional data transmission to txfifo is necessary to drive the spi-clk and reset certain values within the spi-slave for the next test.</p>
<p>The current write tests cover various polarity, phase, and endianness scenarios using test data from 0x00 to 0xff, all yielding correct results.</p>
</section>
</section>
</section>
<section id="hardware-interface">
<h3>2.3.3 Hardware Interface<a class="headerlink" href="#hardware-interface" title="Link to this heading"></a></h3>
<p>Within the U500 platform, only a single SPI (SPI0) interface is presently available, specifically designated for connecting to an SD card. The top-level module delineates the following correspondence between the SPI interface signals and the SD card signals:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">SPI Signal</th>
<th style="text-align: center;">Top-level SD Card Signal</th>
<th style="text-align: center;">I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">SCK</td>
<td style="text-align: center;">sdio_sdio_clk</td>
<td style="text-align: center;">output</td>
</tr>
<tr>
<td style="text-align: center;">MOSI</td>
<td style="text-align: center;">sdio_sdio_cmd</td>
<td style="text-align: center;">output</td>
</tr>
<tr>
<td style="text-align: center;">MISO</td>
<td style="text-align: center;">sdio_sdio_dat_0</td>
<td style="text-align: center;">input</td>
</tr>
<tr>
<td style="text-align: center;">CS</td>
<td style="text-align: center;">sdio_sdio_dat_3</td>
<td style="text-align: center;">output</td>
</tr>
</tbody>
</table><section id="detailed-explanation">
<h4>Detailed Explanation:<a class="headerlink" href="#detailed-explanation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>SCK (Serial Clock)</strong>: The SPI clock signal, utilized for synchronizing data transmission, corresponds to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_clk</span></code> signal at the top-level module and is an output signal.</p></li>
<li><p><strong>MOSI (Master Out Slave In)</strong>: The signal for transmitting data from the master device to the slave device. In the context of SD card communication, this represents the master device (e.g., microprocessor) transmitting commands or data to the SD card. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_cmd</span></code> signal at the top-level module and is an output signal.</p></li>
<li><p><strong>MISO (Master In Slave Out)</strong>: The signal for transmitting data from the slave device to the master device. In the context of SD card communication, this represents the SD card returning data or responses to the master device. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_dat_0</span></code> signal at the top-level module and is an input signal.</p></li>
<li><p><strong>CS (Chip Select)</strong>: The signal used to select a specific slave device (SD card) for communication. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_dat_3</span></code> signal at the top-level module and is an output signal.</p></li>
</ul>
</section>
</section>
<section id="id10">
<h3>2.3.4 Registers<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<section id="controller-memory-map-configuration">
<h4>Controller Memory Map Configuration<a class="headerlink" href="#controller-memory-map-configuration" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Offset</th>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">sckdiv</td>
<td style="text-align: center;">Serial clock divisor</td>
</tr>
<tr>
<td style="text-align: center;">0x04</td>
<td style="text-align: center;">sckmode</td>
<td style="text-align: center;">Serial clock mode</td>
</tr>
<tr>
<td style="text-align: center;">0x10</td>
<td style="text-align: center;">csid</td>
<td style="text-align: center;">Chip select ID</td>
</tr>
<tr>
<td style="text-align: center;">0x14</td>
<td style="text-align: center;">csdef</td>
<td style="text-align: center;">Chip select default</td>
</tr>
<tr>
<td style="text-align: center;">0x18</td>
<td style="text-align: center;">csmode</td>
<td style="text-align: center;">Chip select mode</td>
</tr>
<tr>
<td style="text-align: center;">0x28</td>
<td style="text-align: center;">delay0</td>
<td style="text-align: center;">Delay control 0</td>
</tr>
<tr>
<td style="text-align: center;">0x2c</td>
<td style="text-align: center;">delay1</td>
<td style="text-align: center;">Delay control 1</td>
</tr>
<tr>
<td style="text-align: center;">0x38</td>
<td style="text-align: center;">extradel</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x3c</td>
<td style="text-align: center;">sampledel</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x40</td>
<td style="text-align: center;">fmt</td>
<td style="text-align: center;">Frame format</td>
</tr>
<tr>
<td style="text-align: center;">0x48</td>
<td style="text-align: center;">txfifo</td>
<td style="text-align: center;">Tx FIFO data</td>
</tr>
<tr>
<td style="text-align: center;">0x4c</td>
<td style="text-align: center;">rxfifo</td>
<td style="text-align: center;">Rx FIFO data</td>
</tr>
<tr>
<td style="text-align: center;">0x50</td>
<td style="text-align: center;">txmark</td>
<td style="text-align: center;">Tx FIFO watermark</td>
</tr>
<tr>
<td style="text-align: center;">0x54</td>
<td style="text-align: center;">rxmark</td>
<td style="text-align: center;">Rx FIFO watermark</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x60</td>
<td style="text-align: center;">fctrl</td>
<td style="text-align: center;">SPI flash interface control</td>
</tr>
<tr>
<td style="text-align: center;">0x64</td>
<td style="text-align: center;">ffmt</td>
<td style="text-align: center;">SPI flash instruction format</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x70</td>
<td style="text-align: center;">ie</td>
<td style="text-align: center;">SPI interrupt enable</td>
</tr>
<tr>
<td style="text-align: center;">0x74</td>
<td style="text-align: center;">ip</td>
<td style="text-align: center;">SPI interrupt pending</td>
</tr>
</tbody>
</table></section>
<section id="register-functionality-overview">
<h4>Register Functionality Overview<a class="headerlink" href="#register-functionality-overview" title="Link to this heading"></a></h4>
<section id="sckdiv">
<h5>SckDiv<a class="headerlink" href="#sckdiv" title="Link to this heading"></a></h5>
<p>The sckdiv register specifies the divisor used to generate the serial clock (SCK). The relationship between the input clock and SCK is defined by the following formula:
$$f_{sck}=\frac{f_{in}}{2(div+1)}$$</p>
<p>The input clock is the bus clock tlclk. The div field is reset to the value 0x3.</p>
<p>Alternatively, for a more detailed context:</p>
<p>The input clock is synchronized with the bus clock, denoted as tlclk. The div field within the sckdiv register, which governs the division factor for SCK generation, is initialized to a default value of 0x3 upon reset.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[11:0]</td>
<td style="text-align: center;">div</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x3</td>
<td style="text-align: center;">Divisor or serial clock</td>
</tr>
<tr>
<td style="text-align: center;">[31:12]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
<section id="seral-clock-mode-register-sckmode">
<h5>Seral Clock Mode Register (sckmode)<a class="headerlink" href="#seral-clock-mode-register-sckmode" title="Link to this heading"></a></h5>
<p>The sckmode register dictates the polarity and phase attributes of the serial clock. Upon reset, the sckmode register is initialized to a default value of 0.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">pha</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Serial clock phase</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">pol</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Serial clock polarity</td>
</tr>
<tr>
<td style="text-align: center;">[31:2]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table><p>Serial Clock Polarity:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">The SCK signal remains at a logical level of 0 at idle</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">The SCK signal remains at a logical level of 1</td>
</tr>
<tr>
<td style="text-align: center;">at idle</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table><p>Serial Clock Phase：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Data is sampled on the rising edge of SCK (leading edge) and shifted out on the falling edge of SCK (trailing edge)</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Data is sampled on the falling edge of SCK (leading edge) and shifted out on the rising edge of SCK (trailing edge)</td>
</tr>
</tbody>
</table></section>
<section id="chip-select-id-register-csid">
<h5>Chip Select ID Register (csid)<a class="headerlink" href="#chip-select-id-register-csid" title="Link to this heading"></a></h5>
<p>The csid register encodes the index of the CS pin to be toggled by the hardware chip select control. The reset value for this register is 0.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[31:0]</td>
<td style="text-align: center;">csid</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0000_0000</td>
<td style="text-align: center;">Chip Select ID</td>
</tr>
</tbody>
</table></section>
<section id="chip-select-default-register-csdef">
<h5>Chip Select Default Register (csdef)<a class="headerlink" href="#chip-select-default-register-csdef" title="Link to this heading"></a></h5>
<p>The csdef register specifies the idle state (polarity) of the CS pins. For all implemented CS pins, the reset value is set to high.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[31:0]</td>
<td style="text-align: center;">csdef</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0000_0001</td>
<td style="text-align: center;">Chip Select Default Value</td>
</tr>
</tbody>
</table></section>
<section id="chip-select-mode-register-csmode">
<h5>Chip Select Mode Register (csmode)<a class="headerlink" href="#chip-select-mode-register-csmode" title="Link to this heading"></a></h5>
<p>The csmode register defines the behavior of the hardware chip select, as detailed in the table below. The reset value is 0 (AUTO). In HOLD mode, the CS pin remains deasserted under the following conditions:</p>
<ul class="simple">
<li><p>A different value is written to either csmode or csid.</p></li>
<li><p>A write to csdef results in a change of state for the selected pin.</p></li>
<li><p>Direct-mapped flash mode is enabled.</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[1:0]</td>
<td style="text-align: center;">mode</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Chip Select Mode</td>
</tr>
<tr>
<td style="text-align: center;">[31:2]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">AUTO</td>
<td style="text-align: center;">Toggle the CS signal at the beginning/end of each frame</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">HOLD</td>
<td style="text-align: center;">Keep the CS signal asserted continuously after the initial frame</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">OFF</td>
<td style="text-align: center;">Disable hardware control over the CS signal</td>
</tr>
</tbody>
</table></section>
<section id="delay-control-registers-delay0-and-delay1">
<h5>Delay Control Registers (delay0 and delay1)<a class="headerlink" href="#delay-control-registers-delay0-and-delay1" title="Link to this heading"></a></h5>
<p>The delay0 and delay1 registers allow the insertion of arbitrary delays in terms of SCK cycles.</p>
<ul class="simple">
<li><p>The cssck field specifies the delay between setting CS and the first rising edge of SCK. An additional half-cycle delay is implied when sckmode.pha = 0. The reset value is 0x01.</p></li>
<li><p>The sckcs field specifies the delay between the last falling edge of SCK and the deassertion of CS. An additional half-cycle delay is implied when sckmode.pha = 1. The reset value is 0x01.</p></li>
<li><p>The intercs field specifies the minimum CS idle time between deassertion and reassertion. The reset value is 0x01.</p></li>
<li><p>The interxfr field specifies the delay between two consecutive frames without deasserting CS. This is applicable only when sckmode is in HOLD or OFF. The reset value is 0x00.</p></li>
</ul>
<p>delay0：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">cssck</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x01</td>
<td style="text-align: center;">CS to SCK Delay</td>
</tr>
<tr>
<td style="text-align: center;">[15:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">[23:16]</td>
<td style="text-align: center;">sckcs</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x01</td>
<td style="text-align: center;">SCK to CS Delay</td>
</tr>
<tr>
<td style="text-align: center;">[31:24]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table><p>delya1：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">intercs</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x01</td>
<td style="text-align: center;">Minimum CS inactive time</td>
</tr>
<tr>
<td style="text-align: center;">[15:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">[23:16]</td>
<td style="text-align: center;">interxfr</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">Maximum interframe delay</td>
</tr>
<tr>
<td style="text-align: center;">[31:24]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
<section id="frame-format-register-fmt">
<h5>Frame Format Register (fmt)<a class="headerlink" href="#frame-format-register-fmt" title="Link to this heading"></a></h5>
<p>The fmt register defines the frame format for transfers initiated via the Programmed I/O (FIFO) interface. The following table describes the proto, endian, and dir fields, which represent the protocol, endianness, and direction, respectively.</p>
<ul class="simple">
<li><p>The len field defines the number of bits per frame, with a permissible range from 0 to 8, inclusive.</p></li>
<li><p>For SPI0, the reset value of the fmt register is 0x0008 0008, which corresponds to proto = single, dir = Tx, endian = MSB, and len = 8.</p></li>
<li><p>For SPI1 and SPI2, the reset value of the fmt register is 0x0008 0000, which corresponds to proto = single, dir = Rx, endian = MSB, and len = 8.</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Fidle Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[1:0]</td>
<td style="text-align: center;">proto</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">SPI Protocol</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">endian</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">SPI endinanness</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">dir</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x1</td>
<td style="text-align: center;">SPI I/O Direction</td>
</tr>
<tr>
<td style="text-align: center;">[15:4]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">[19:16]</td>
<td style="text-align: center;">len</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x8</td>
<td style="text-align: center;">Number of bits per frame</td>
</tr>
<tr>
<td style="text-align: center;">[31:20]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table><p>SPI Protocol：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Data Pins</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">DQ0(MOSI), DQ1(MISO)</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Dual</td>
<td style="text-align: center;">DQ0, DQ1</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Quad</td>
<td style="text-align: center;">DQ0, DQ1, DQ2, DQ3</td>
</tr>
</tbody>
</table><p>SPI Endianness：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Transmit most-significant bit (MSB) first</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Transmit least-significant bit (LSB) first</td>
</tr>
</tbody>
</table><p>SPI I/O Direction：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Rx: In dual and quad protocols, the DQ pins are tri-stated. In the single protocol, the DQ0 pin is driven by the transmit data as usual.</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Tx: Receive data is not stored in the receive FIFO.</td>
</tr>
</tbody>
</table></section>
<section id="id11">
<h5>Transmit Data Register (txdata)<a class="headerlink" href="#id11" title="Link to this heading"></a></h5>
<p>Writing to the txdata register loads the transmit FIFO with the value in the data field.</p>
<p>For the case where fmt.len &lt; 8, the value should be left-aligned when fmt.endian = MSB, and right-aligned when fmt.endian = LSB.</p>
<p>The full flag is set when the transmit FIFO is ready to accept a new entry; when set, writes to txdata are ignored. On read, the data field returns 0x00.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">data</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">Transmit Data</td>
</tr>
<tr>
<td style="text-align: center;">[30:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">31</td>
<td style="text-align: center;">full</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">FIFO full flag</td>
</tr>
</tbody>
</table></section>
<section id="id12">
<h5>Receive Data Register (rxdata)<a class="headerlink" href="#id12" title="Link to this heading"></a></h5>
<p>Reading the rxdata register dequeues a frame from the receive FIFO.</p>
<p>For the case where fmt.len &lt; 8, the value should be left-aligned when fmt.endian = MSB, and right-aligned when fmt.endian = LSB.</p>
<p>The empty flag is set when the receive FIFO contains a new entry available for reading; when set, the data field does not contain a valid frame. Writes to rxdata are ignored.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[7:0]</td>
<td style="text-align: center;">data</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Received Data</td>
</tr>
<tr>
<td style="text-align: center;">[30:8]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">31</td>
<td style="text-align: center;">empty</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">FIFO empty flag</td>
</tr>
</tbody>
</table></section>
<section id="transmit-watermark-register-txmark">
<h5>Transmit Watermark Register (txmark)<a class="headerlink" href="#transmit-watermark-register-txmark" title="Link to this heading"></a></h5>
<p>The txmark register specifies the threshold that triggers the Tx FIFO watermark interrupt.
For spi0, the reset value is 1; for spi1 and spi2, the reset value is 0.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[2:0]</td>
<td style="text-align: center;">txmark</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x1</td>
<td style="text-align: center;">Transmit watermark</td>
</tr>
<tr>
<td style="text-align: center;">[31:3]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
<section id="receive-watermark-register-rxmark">
<h5>Receive Watermark Register (rxmark)<a class="headerlink" href="#receive-watermark-register-rxmark" title="Link to this heading"></a></h5>
<p>The rxmark specifies the threshold that triggers the Rx FIFO watermark interrupt. The reset value is 0.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[2:0]</td>
<td style="text-align: center;">rxmark</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Receive watermark</td>
</tr>
<tr>
<td style="text-align: center;">[31:3]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
<section id="spi-flash-interface-control-register-fctrl">
<h5>SPI Flash Interface Control Register (fctrl)<a class="headerlink" href="#spi-flash-interface-control-register-fctrl" title="Link to this heading"></a></h5>
<p>When the en bit of the fctrl register is set, the controller enters SPI Flash mode. Access to the memory-mapped region will cause the controller to automatically perform SPI Flash read sequences in hardware. The reset value is 0x1.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">en</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x1</td>
<td style="text-align: center;">SPI Flash Mode Select</td>
</tr>
<tr>
<td style="text-align: center;">[31:1]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
<section id="spi-flash-instruction-format-register-ffmt">
<h5>SPI Flash Instruction Format Register (ffmt)<a class="headerlink" href="#spi-flash-instruction-format-register-ffmt" title="Link to this heading"></a></h5>
<p>The ffmt register defines the format of the SPI Flash read instruction issued by the controller when accessing the memory-mapped region when the controller is in SPI Flash mode.</p>
<p>An instruction consists of a command byte, followed by a variable number of address bytes, dummy cycles (padding), and data bytes. The table below describes the function and reset value of each field.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">cmd_en</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x1</td>
<td style="text-align: center;">Enable sending of command</td>
</tr>
<tr>
<td style="text-align: center;">[3:1]</td>
<td style="text-align: center;">addr_len</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x3</td>
<td style="text-align: center;">Number of address bytes (0 to 4)</td>
</tr>
<tr>
<td style="text-align: center;">[7:4]</td>
<td style="text-align: center;">pad_cnt</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Number of dummy cycles</td>
</tr>
<tr>
<td style="text-align: center;">[9:8]</td>
<td style="text-align: center;">cmd_proto</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Protocol for transmitting command</td>
</tr>
<tr>
<td style="text-align: center;">[11:10]</td>
<td style="text-align: center;">addr_proto</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Protocol for transmitting address and padding</td>
</tr>
<tr>
<td style="text-align: center;">[13:12]</td>
<td style="text-align: center;">data_proto</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Protocol for receiving data bytes</td>
</tr>
<tr>
<td style="text-align: center;">[15:14]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
<tr>
<td style="text-align: center;">[23:16]</td>
<td style="text-align: center;">cmd_code</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x03</td>
<td style="text-align: center;">Value of command byte</td>
</tr>
<tr>
<td style="text-align: center;">[31:24]</td>
<td style="text-align: center;">pad_code</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">First 8 bits to transmit during dummy cycles</td>
</tr>
</tbody>
</table></section>
<section id="spi-interrupt-registers-ie-and-ip">
<h5>SPI Interrupt Registers (ie and ip)<a class="headerlink" href="#spi-interrupt-registers-ie-and-ip" title="Link to this heading"></a></h5>
<p>The ie register controls which SPI interrupts are enabled, while ip is a read-only register indicating pending interrupt conditions. The reset value of ie is zero.</p>
<p>The txwm condition is triggered when the number of entries in the transmit FIFO is strictly less than the count specified by the txmark register. The pending bit is cleared when the number of enqueued entries is sufficiently large to exceed the watermark.</p>
<p>The rxwm condition is triggered when the number of entries in the receive FIFO is strictly greater than the count specified by the rxmark register. The pending bit is cleared when the number of dequeued entries is sufficiently small to fall below the watermark.</p>
<p>SPI Interrupt Enable Register (ie):</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">txwm</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Transmit watermark enable</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">rxwm</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Receive watermark enable</td>
</tr>
<tr>
<td style="text-align: center;">[31:2]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table><p>SPI Watermark Interrupt Pending Register (ip):</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Field Name</th>
<th style="text-align: center;">Attr.</th>
<th style="text-align: center;">Rst.</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">txwm</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Transmit watermark pending</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">rxwm</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">Receive watermark pending</td>
</tr>
<tr>
<td style="text-align: center;">[31:2]</td>
<td style="text-align: center;">Reserved</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Reserved</td>
</tr>
</tbody>
</table></section>
</section>
</section>
<section id="id13">
<h3>2.3.5  Checklist<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
</section>
</section>
<section id="jtag">
<h2>2.4 JTAG<a class="headerlink" href="#jtag" title="Link to this heading"></a></h2>
<section id="jtag-technical-specification">
<h3>2.4.1 JTAG Technical Specification<a class="headerlink" href="#jtag-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-22.png" /></p>
</section>
<section id="id14">
<h3>Description<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>JTAG (Joint Test Action Group), an international standard testing protocol conforming to IEEE 1149.1, is primarily used for internal chip testing. Many advanced devices, such as DSPs and FPGAs, support the JTAG protocol. The standard JTAG interface comprises four lines: TMS, TCK, TDI, and TDO, representing Mode Select, Clock, Data Input, and Data Output, respectively.</p>
<p>Initially designed for chip testing, JTAG operates by defining a TAP (Test Access Port) within the device, allowing internal nodes to be tested using dedicated JTAG tools. JTAG’s unique capability enables multiple devices to be daisy-chained via the JTAG interface, forming a JTAG chain that facilitates individual device testing. Beyond testing, the JTAG interface is also commonly utilized for In-System Programming (ISP), enabling programming of components like FLASH memory.</p>
<p>JTAG’s in-system programming approach revolutionizes traditional production flows, where chips were pre-programmed before being soldered onto boards. This method simplifies the process by allowing devices to be secured onto the board first, followed by JTAG programming, significantly accelerating project timelines. The JTAG interface can program all components within a PSD (Programmable System Device) chip.</p>
</section>
<section id="id15">
<h3>2.4.2 Theory of Operation<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<section id="module-structure">
<h4>2.4.2.1 Module Structure<a class="headerlink" href="#module-structure" title="Link to this heading"></a></h4>
<section id="meishav100-dm-and-jtag-connection-diagram">
<h5>MEISHAV100 DM and JTAG Connection Diagram<a class="headerlink" href="#meishav100-dm-and-jtag-connection-diagram" title="Link to this heading"></a></h5>
<p>The DM and JTAG connection diagram for MEISHAV100 is as follows:</p>
<div align=center>  <p><img alt="alt text" src="../_images/image-17.png" /><br />DM and JTAG Connection</p>
<div>
<div align=left><div>   <p>Since the project is generated by Chisel, the modules used are in accordance with the specifications of SiFive and UC Berkeley.</p>
<p>Here, the TLDebugModule uses the Debug design from Rocket-Chip. The file location is:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>:/src/main/scala/device/debug
<span class="p">|</span>-<span class="w"> </span>Debug.scala
</pre></div>
</div>
<p>The DebugTransportModuleJTAG uses the design from the following location:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>:/src/main/scala/device/debug
<span class="p">|</span>-<span class="w"> </span>DebugTransport.scala
:/src/main/scala/JtagTap.scala
<span class="p">|</span>-<span class="w"> </span>JtagTap.scala
<span class="p">|</span>-<span class="w"> </span>JtagShifter.scala
<span class="p">|</span>-<span class="w"> </span>JtagStateMachine.scala
</pre></div>
</div>
</section>
<section id="top-module-tldebugmodule-slave">
<h5>2.4.2.1.1 top_module: TLDebugModule (slave)<a class="headerlink" href="#top-module-tldebugmodule-slave" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p><strong>TLDebugModuleOuterAsync</strong></p>
<ul>
<li><p>DMIToTL</p></li>
<li><p>TLXbar_7</p></li>
<li><p>TLDebugModuleOuter</p></li>
<li><p>IntSyncCrossingSource</p></li>
<li><p>TLAsyncCrossingSource</p></li>
<li><p>AsyncQueueSource_1</p></li>
</ul>
</li>
<li><p><strong>TLDebugModuleInnerAsync</strong></p>
<ul>
<li><p>TLDebugModuleInner</p></li>
<li><p>TLAsyncCrossingSink</p></li>
<li><p>AsyncQueueSink_1</p></li>
<li><p>AsyncQueueSource_2</p></li>
<li><p>AsyncQueueSink_2</p></li>
<li><p>ResetCatchAndSync_d3</p></li>
</ul>
</li>
</ul>
</section>
<section id="top-module-debugtransportmodulejtag-master-s-interface">
<h5>2.4.2.1.2 top_module: DebugTransportModuleJTAG (master’s interface)<a class="headerlink" href="#top-module-debugtransportmodulejtag-master-s-interface" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>CaptureUpdateChain (as dtmInfoChain)</p></li>
<li><p>CaptureUpdateChain_1 (as dtmAccessChain)</p></li>
<li><p>CaptureChain (as idcodeChain)</p></li>
<li><p>JtagTapController</p>
<ul>
<li><p>JtagStateMachine</p></li>
<li><p>CaptureUpdateChain_2 (as irChain)</p></li>
</ul>
</li>
<li><p>JtagBypassChain</p></li>
</ul>
<p>Overall, only DR Bypass and IR are implemented, which is not related to verification.</p>
<p>For reference, the Rocket-Chip project can be found at: <a class="reference external" href="https://github.com/chipsalliance/rocket-chip/tree/master">https://github.com/chipsalliance/rocket-chip/tree/master</a>.</p>
</section>
</section>
<section id="jtag-tapc-state-machine">
<h4>2.4.2.2 JTAG TAPC State Machine<a class="headerlink" href="#jtag-tapc-state-machine" title="Link to this heading"></a></h4>
<p>The JTAG controller incorporates the standard TAPC state machine as depicted below, with the state machine handling clocking via TCK.</p>
<div align=center><p><img alt="alt text" src="../_images/image-18.png" /><br />JTAG Controller</p>
<div>
<div align=left><div>  </section>
<section id="resetting-jtag-logic">
<h4>2.4.2.3  Resetting JTAG Logic<a class="headerlink" href="#resetting-jtag-logic" title="Link to this heading"></a></h4>
<p>Asynchronous reset of the JTAG logic must be achieved by asserting the power-on-reset signal, which drives an internal jtag_reset signal.</p>
<p>Asserting jtag_reset will reset both the JTAG DTM and the debug module test logic. Since certain debug logic requires a synchronous reset, the jtag_reset signal is internally synchronized within the FU540-C000.</p>
<p>During operation, the JTAG DTM logic can also be reset without involving jtag_reset by asserting jtag_TMS while issuing five jtag_TCK clock ticks. This operation only resets the JTAG DTM, not the debug module.</p>
</section>
<section id="jtag-clocking">
<h4>2.4.2.4 JTAG Clocking<a class="headerlink" href="#jtag-clocking" title="Link to this heading"></a></h4>
<p>The JTAG logic always operates within its own clock domain, which is clocked by jtag_TCK. The JTAG logic is fully static and has no minimum clock frequency requirement. The maximum jtag_TCK frequency is part-specific.</p>
</section>
<section id="jtag-standard-instructions">
<h4>2.4.2.5 JTAG Standard Instructions<a class="headerlink" href="#jtag-standard-instructions" title="Link to this heading"></a></h4>
<p>The JTAG DTM implements the BYPASS and IDCODE instructions.
The IDCODE for the FU540-C000 is set to 0x20000913.</p>
</section>
<section id="jtag-debug-commands">
<h4>2.4.2.6 JTAG Debug Commands<a class="headerlink" href="#jtag-debug-commands" title="Link to this heading"></a></h4>
<p>The JTAG DEBUG instruction accesses the SiFive debug module by connecting the debug scan register between jtag_TDI and jtag_TDO.</p>
</section>
<section id="overview-of-states">
<h4>2.4.2.7 Overview of States<a class="headerlink" href="#overview-of-states" title="Link to this heading"></a></h4>
<p>A conceptual view is provided of the states a hart transitions through during run/halt debugging, which are influenced by various fields in dmcontrol, abstractcs, abstractauto, and command.</p>
<div align=center><p><img alt="alt text" src="../_images/image-19.png" /></p>
<div>
<div align=left><div>   </section>
</section>
<section id="jtag-design-verification">
<h3>2.4.3 JTAG Design Verification<a class="headerlink" href="#jtag-design-verification" title="Link to this heading"></a></h3>
<section id="id16">
<h4>Goals<a class="headerlink" href="#id16" title="Link to this heading"></a></h4>
<section id="id17">
<h5>DV<a class="headerlink" href="#id17" title="Link to this heading"></a></h5>
<p>Verify JTAG IP features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="id18">
<h4>Design features<a class="headerlink" href="#id18" title="Link to this heading"></a></h4>
<p>For detailed information on JTAG design features, please see the <strong>JTAG Technical Specification</strong>.</p>
</section>
<section id="id19">
<h4>Testbench architecture<a class="headerlink" href="#id19" title="Link to this heading"></a></h4>
<section id="id20">
<h5>Top level testbench<a class="headerlink" href="#id20" title="Link to this heading"></a></h5>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>JTAG IOs</p></li>
</ul>
</section>
</section>
<section id="id21">
<h4>Global types &amp; methods<a class="headerlink" href="#id21" title="Link to this heading"></a></h4>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">JTAG_env_pkg</span></code></p>
</section>
<section id="id22">
<h4>TL_agent<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<p>JTAG Device instantiates <code class="docutils literal notranslate"><span class="pre">tl_agent</span></code> which provides the ability to drive and independently monitor random traffic via TL host interface into JTAG Device.</p>
</section>
<section id="jtag-agent">
<h4>JTAG_agent<a class="headerlink" href="#jtag-agent" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">JTAG</span> <span class="pre">agent</span></code> is used to drive and monitor JTAG items.</p>
</section>
<section id="id23">
<h4>2.4.3.1 Testplan<a class="headerlink" href="#id23" title="Link to this heading"></a></h4>
<section id="allocate-resources-initialize-member-variables">
<h5>2.4.3.1.1 Allocate resources, initialize member variables.<a class="headerlink" href="#allocate-resources-initialize-member-variables" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">uvm_component</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>
<span class="w">        </span><span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>
<span class="w">        </span><span class="n">set_type_override_by_type</span><span class="p">(</span><span class="n">dv_lib_pkg</span><span class="o">::</span><span class="n">dv_base_env_cfg</span><span class="p">#(</span><span class="n">tlul_base_env_pkg</span><span class="o">::</span><span class="n">tlul_base_reg_block</span><span class="p">)</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
<span class="w">        </span><span class="n">set_type_override_by_type</span><span class="p">(</span><span class="n">tlul_base_env_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
<span class="w">        </span><span class="n">cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;test_cfg&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">jtag_base_env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jtag_env_pkg</span><span class="o">::</span><span class="n">jtag_env</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;jtag_base_env&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">dr_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dr_seq&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dmstatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmstatus&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dtmcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dtmcs&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dmcontrol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmcontrol&quot;</span><span class="p">);</span><span class="w">        </span>
<span class="w">        </span><span class="n">dmabstractcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmabstractcs&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">////uart_base_env = uart_env::type_id::create(&quot;uart_base_env&quot;, this);</span>
<span class="w">        </span><span class="c1">////set_type_override_by_type(dv_base_scoreboard#(dv_base_reg_pkg::dv_base_reg_block,dv_base_env_cfg,dv_base_env_cov)::get_type(), spi_scoreboard::get_type());</span>
<span class="w">    </span><span class="k">endfunction</span><span class="w"> </span><span class="c1">//new()</span>
</pre></div>
</div>
</section>
<section id="read-id-code-reading-idcode-instruction">
<h5>2.4.3.1.2 read_id_code(Reading IDCODE instruction)<a class="headerlink" href="#read-id-code-reading-idcode-instruction" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_id_code</span><span class="p">();</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_IDCODE</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mh">32&#39;h0000_0000</span><span class="p">});</span><span class="w">  </span><span class="c1">// randomize value  IDCODE WIDTH is 32</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="mh">32&#39;h20000913</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;read_id_code&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;%h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">))</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dtmcs-reading-the-dtm-status">
<h5>2.4.3.1.3 read_dtmcs(Reading the DTM status)<a class="headerlink" href="#read-dtmcs-reading-the-dtm-status" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">abits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="p">;</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">idle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`DTM_IDLE_DELAY_CYCLE</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DTMCS</span><span class="p">);</span>
<span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mh">32&#39;h0000_0000</span><span class="p">});</span><span class="w">  </span><span class="c1">// randomize value  IDCODE WIDTH is 32</span>
<span class="k">if</span><span class="p">({</span><span class="mh">14&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">idle</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">abits</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mb">4&#39;b1</span><span class="p">}</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;read_dtmcs&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;%h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">))</span>
<span class="k">end</span>
<span class="c1">// data_array = new[4];</span>
<span class="c1">// for ( int i = 0; i &lt; 4; i++ ) begin</span>
<span class="c1">//     data_array[i] = this.dr_seq.rsp.dout[(i*8)+:8];</span>
<span class="c1">// end</span>
<span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dtmcs:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="c1">// this.dtmcs.dmihardreset = this.dr_seq.rsp.dout[17];</span>
<span class="c1">// this.dtmcs.dmireset = this.dr_seq.rsp.dout[16];</span>
<span class="c1">// this.dtmcs.idle = this.dr_seq.rsp.dout[14:12];</span>
<span class="c1">// this.dtmcs.dmistat = this.dr_seq.rsp.dout[11:10];</span>
<span class="c1">// this.dtmcs.abits = this.dr_seq.rsp.dout[9:4];</span>
<span class="c1">// this.dtmcs.version = this.dr_seq.rsp.dout[3:0];</span>
<span class="k">endtask</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">this.dtmcs.unpack_ints(data_array);</span></code> is responsible for unpacking the integer values from the <code class="docutils literal notranslate"><span class="pre">data_array</span></code> and assigning them to the respective member variables of the <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code> object.</p>
</section>
<section id="read-dmcontrol-reading-debug-module-control">
<h5>2.4.3.1.4 read_dmcontrol(Reading Debug Module Control)<a class="headerlink" href="#read-dmcontrol-reading-debug-module-control" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_DMCONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dmcontrol:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="dmi-read-reading-data-via-debug-module-interface">
<h5>2.4.3.1.5  dmi_read(Reading data via Debug Module Interface)<a class="headerlink" href="#dmi-read-reading-data-via-debug-module-interface" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">dmi_read</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">output</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 执行DMI读操作</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DMI</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// read dr more time , wait data flush complete</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">32&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h1</span><span class="p">});</span>
<span class="w">    </span><span class="c1">//data[31:0] = this.dr_seq.rsp.dout[33:2];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">32&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h1</span><span class="p">});</span>
<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">33</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// this.dr_seq.send_dr(this.jtag_base_env.m_jtag_agent.sequencer, `DTM_ABITS + 34, {address[`DTM_ABITS-1:0], 32&#39;h0, 2&#39;h1});</span>
<span class="w">    </span><span class="c1">// data[31:0] = this.dr_seq.rsp.dout[33:2];</span>
<span class="w">    </span><span class="c1">// 等待读操作完成并检查状态</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">check_timeout</span><span class="o">++</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="no">`uvm_fatal</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;timeout,address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2&#39;h3</span><span class="p">);</span><span class="w"> </span><span class="c1">// repeat try once</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="c1">// clear status</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmireset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_info</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: success&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dmstatus-reading-data-via-debug-module-interface">
<h5>2.4.3.1.6 read_dmstatus(Reading data via Debug Module Interface)<a class="headerlink" href="#read-dmstatus-reading-data-via-debug-module-interface" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmstatus</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_DMSTATUS</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// data_array = new[4];</span>
<span class="w">    </span><span class="c1">// for ( int i = 0; i &lt; 4; i++ ) begin</span>
<span class="w">    </span><span class="c1">//     data_array[i] = data[(i*8)+:8];</span>
<span class="w">    </span><span class="c1">// end</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmstatus</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dmstatus:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmstatus</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="write-dmcontrol-writing-debug-module-control">
<h5>2.4.3.1.7 write_dmcontrol（Writing Debug Module Control）<a class="headerlink" href="#write-dmcontrol-writing-debug-module-control" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">pack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span><span class="n">dmi_write</span><span class="p">(</span><span class="n">DM_DMCONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;write_dmcontrol:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="dmi-write-writing-data-via-debug-module-interface">
<h5>2.4.3.1.8 dmi_write(Writing data via Debug Module Interface)<a class="headerlink" href="#dmi-write-writing-data-via-debug-module-interface" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">dmi_write</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 执行DMI写操作</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DMI</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">2&#39;h2</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// 等待写操作完成并检查状态</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">check_timeout</span><span class="o">++</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="no">`uvm_fatal</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;timeout,address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2&#39;h3</span><span class="p">);</span><span class="w"> </span><span class="c1">// repeat try once</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_info</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: success&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dmabstractcs-reading-abstract-control-and-status">
<h5>2.4.3.1.9 read_dmabstractcs(Reading Abstract Control and Status)<a class="headerlink" href="#read-dmabstractcs-reading-abstract-control-and-status" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmabstractcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_ABS_CS</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmabstractcs</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;dmabstractcs:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmabstractcs</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="execute-progbuf-setting-buffer-area-progbufsize">
<h5>2.4.3.1.10  execute_progbuf(Setting buffer area progbufsize)<a class="headerlink" href="#execute-progbuf-setting-buffer-area-progbufsize" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">execute_progbuf</span><span class="p">();</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h1</span><span class="p">,</span><span class="w"> </span><span class="mh">24&#39;h0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;execute_progbuf&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="access-hart-reg">
<h5>2.4.3.1.11 access_hart_reg<a class="headerlink" href="#access-hart-reg" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">access_hart_reg</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">regno</span><span class="p">);</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">});</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;access_hart_reg: &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="access-hart-mem">
<h5>2.4.3.1.12 access_hart_mem<a class="headerlink" href="#access-hart-mem" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">access_hart_mem</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">target_specific</span><span class="p">);</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h2</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">target_specific</span><span class="p">,</span><span class="w"> </span><span class="mh">14&#39;h0</span><span class="p">});</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;access_hart_mem: &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">target_specific</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="write-dmabstract-cmd">
<h5>2.4.3.1.13 write_dmabstract_cmd<a class="headerlink" href="#write-dmabstract-cmd" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">control</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="p">};</span>
<span class="w">    </span><span class="n">dmi_write</span><span class="p">(</span><span class="n">DM_ABS_CMD</span><span class="p">,</span><span class="w"> </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;write_dmabstract_cmd: &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="the-program-is-running">
<h5>2.4.3.1.14 The program is running.<a class="headerlink" href="#the-program-is-running" title="Link to this heading"></a></h5>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span><span class="w"> </span>
<span class="w">        </span><span class="n">read_id_code</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">        </span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="n">read_dmcontrol</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">        </span><span class="n">read_dmstatus</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="c1">// halt all cpu</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">haltreq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">hasel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">hartsello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">10&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">dmactive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be 1 for debug</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">        </span><span class="p">#</span><span class="mi">5</span><span class="n">us</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="c1">// test abstract cmd</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dmabstractcs</span><span class="p">();</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">access_hart_reg</span><span class="p">(</span><span class="mi">2</span><span class="cm">/*aarsize*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*aarpostincrement*/</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="cm">/*postexec*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*transfer*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*write*/</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="cm">/*regno*/</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">access_hart_mem</span><span class="p">(</span><span class="mi">0</span><span class="cm">/*aamvirtual*/</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="cm">/*aamsize*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*aampostincrement*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*write*/</span><span class="p">,</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="cm">/*target_specific*/</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">execute_progbuf</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
</pre></div>
</div>
</section>
</section>
<section id="fpga-verification-via-openocd">
<h4>FPGA Verification Via OpenOCD<a class="headerlink" href="#fpga-verification-via-openocd" title="Link to this heading"></a></h4>
<p>Users interact with the debugging host (such as a laptop) running a debugger (such as GDB). The debugger communicates with the debug adapter (for example, <strong>OpenOCD</strong>, which may include a hardware driver) to interface with the debug transport hardware (such as an Olimex USB-JTAG adapter). The debug transport hardware connects the debug host to the platform’s Debug Transport Module (DTM). The DTM uses the Debug Module Interface (DMI) to provide access to one or more Debug Modules (DM).</p>
<p>To stop one or more harts, the debugger selects them, sets haltreq, and then waits for the allhalted indication that the harts have stopped. It can then clear haltreq to 0, or keep it high to catch harts that reset while paused.</p>
<p>The platform is a single integrated circuit composed of one or more components. Some components may be RISC-V cores, while others may have different functions. Typically, they will all be connected to a single system bus. A single RISC-V core contains one or more hardware threads, called harts.</p>
</section>
</section>
<section id="id24">
<h3>2.4.4 Hardware Interfaces<a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<p>The mapping of top-level JTAG signals in the U500 module is represented in the following table:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">JTAG Singal</th>
<th style="text-align: center;">Top JTAG Singal</th>
<th style="text-align: center;">I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">TCK</td>
<td style="text-align: center;">jtag_jtag_TCK</td>
<td style="text-align: center;">input</td>
</tr>
<tr>
<td style="text-align: center;">TMS</td>
<td style="text-align: center;">jtag_jtag_TMS</td>
<td style="text-align: center;">input</td>
</tr>
<tr>
<td style="text-align: center;">TDI</td>
<td style="text-align: center;">jtag_jtag_TDI</td>
<td style="text-align: center;">input</td>
</tr>
<tr>
<td style="text-align: center;">TDO</td>
<td style="text-align: center;">jtag_jtag_TDO</td>
<td style="text-align: center;">output</td>
</tr>
</tbody>
</table></section>
<section id="id25">
<h3>2.4.5 Registers<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<section id="debug-module-debug-bus-registers">
<h4>2.4.5.1 Debug Module Debug Bus Registers<a class="headerlink" href="#debug-module-debug-bus-registers" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Address</th>
<th style="text-align: center;">Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x04</td>
<td style="text-align: center;">Abstract Data 0 (data0)</td>
</tr>
<tr>
<td style="text-align: center;">0x0f</td>
<td style="text-align: center;">Abstract Data 11 (data11)</td>
</tr>
<tr>
<td style="text-align: center;">0x10</td>
<td style="text-align: center;">Debug Module Control (dmcontrol)</td>
</tr>
<tr>
<td style="text-align: center;">0x11</td>
<td style="text-align: center;">Debug Module Status (dmstatus)</td>
</tr>
<tr>
<td style="text-align: center;">0x12</td>
<td style="text-align: center;">Hart Info (hartinfo)</td>
</tr>
<tr>
<td style="text-align: center;">0x13</td>
<td style="text-align: center;">Halt Summary 1 (haltsum1)</td>
</tr>
<tr>
<td style="text-align: center;">0x14</td>
<td style="text-align: center;">Hart Array Window Select (hawindowsel)</td>
</tr>
<tr>
<td style="text-align: center;">0x15</td>
<td style="text-align: center;">Hart Array Window (hawindow)</td>
</tr>
<tr>
<td style="text-align: center;">0x16</td>
<td style="text-align: center;">Abstract Control and Status (abstractcs)</td>
</tr>
<tr>
<td style="text-align: center;">0x17</td>
<td style="text-align: center;">Abstract Command (command)</td>
</tr>
<tr>
<td style="text-align: center;">0x18</td>
<td style="text-align: center;">Abstract Command Autoexec (abstractauto)</td>
</tr>
<tr>
<td style="text-align: center;">0x19</td>
<td style="text-align: center;">Configuration String Pointer 0 (confstrptr0)</td>
</tr>
<tr>
<td style="text-align: center;">0x1a</td>
<td style="text-align: center;">Configuration String Pointer 1 (confstrptr1)</td>
</tr>
<tr>
<td style="text-align: center;">0x1b</td>
<td style="text-align: center;">Configuration String Pointer 2 (confstrptr2)</td>
</tr>
<tr>
<td style="text-align: center;">0x1c</td>
<td style="text-align: center;">Configuration String Pointer 3 (confstrptr3)</td>
</tr>
<tr>
<td style="text-align: center;">0x1d</td>
<td style="text-align: center;">Next Debug Module (nextdm)</td>
</tr>
<tr>
<td style="text-align: center;">0x20</td>
<td style="text-align: center;">Program Buffer 0 (progbuf0)</td>
</tr>
<tr>
<td style="text-align: center;">0x2f</td>
<td style="text-align: center;">Program Buffer 15 (progbuf15)</td>
</tr>
<tr>
<td style="text-align: center;">0x30</td>
<td style="text-align: center;">Authentication Data (authdata)</td>
</tr>
<tr>
<td style="text-align: center;">0x34</td>
<td style="text-align: center;">Halt Summary 2 (haltsum2)</td>
</tr>
<tr>
<td style="text-align: center;">0x35</td>
<td style="text-align: center;">Halt Summary 3 (haltsum3)</td>
</tr>
<tr>
<td style="text-align: center;">0x37</td>
<td style="text-align: center;">System Bus Address 127:96 (sbaddress3)</td>
</tr>
<tr>
<td style="text-align: center;">0x38</td>
<td style="text-align: center;">System Bus Access Control and Status (sbcs)</td>
</tr>
<tr>
<td style="text-align: center;">0x39</td>
<td style="text-align: center;">System Bus Address 31:0 (sbaddress0)</td>
</tr>
<tr>
<td style="text-align: center;">0x3a</td>
<td style="text-align: center;">System Bus Address 63:32 (sbaddress1)</td>
</tr>
<tr>
<td style="text-align: center;">0x3b</td>
<td style="text-align: center;">System Bus Address 95:64 (sbaddress2)</td>
</tr>
<tr>
<td style="text-align: center;">0x3c</td>
<td style="text-align: center;">System Bus Data 31:0 (sbdata0)</td>
</tr>
<tr>
<td style="text-align: center;">0x3d</td>
<td style="text-align: center;">System Bus Data 63:32 (sbdata1)</td>
</tr>
<tr>
<td style="text-align: center;">0x3e</td>
<td style="text-align: center;">System Bus Data 95:64 (sbdata2)</td>
</tr>
<tr>
<td style="text-align: center;">0x3f</td>
<td style="text-align: center;">System Bus Data 127:96 (sbdata3)</td>
</tr>
<tr>
<td style="text-align: center;">0x40</td>
<td style="text-align: center;">Halt Summary 0 (haltsum0)</td>
</tr>
</tbody>
</table></section>
<section id="dtm-jtag-dtm-registers">
<h4>2.4.5.2 DTM JTAG DTM Registers<a class="headerlink" href="#dtm-jtag-dtm-registers" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Address</th>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Descripition</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">BYPASS</td>
<td style="text-align: center;">JTAG recommends this encoding</td>
</tr>
<tr>
<td style="text-align: center;">0x01</td>
<td style="text-align: center;">IDCODE</td>
<td style="text-align: center;">JTAG recommends this encoding</td>
</tr>
<tr>
<td style="text-align: center;">0x10</td>
<td style="text-align: center;">DTM Control and Status (dtmcs)</td>
<td style="text-align: center;">For Debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x11</td>
<td style="text-align: center;">Debug Module Interface Access (dmi)</td>
<td style="text-align: center;">For Debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x12</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x13</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x14</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x15</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x16</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x17</td>
<td style="text-align: center;">Reserved (BYPASS)</td>
<td style="text-align: center;">Reserved for future RISC-V debugging</td>
</tr>
<tr>
<td style="text-align: center;">0x1f</td>
<td style="text-align: center;">BYPASS</td>
<td style="text-align: center;">JTAG requires this encoding</td>
</tr>
</tbody>
</table><section id="idcode-0x01">
<h5>2.4.5.2.1 IDCODE(0X01)<a class="headerlink" href="#idcode-0x01" title="Link to this heading"></a></h5>
<p>When the TAP state machine is reset, this register (located in the Instruction Register, IR) is selected. Its definition is exactly consistent with that specified in the IEEE Standard 1149.1-2013.</p>
<p>This entire register is read-only.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">31:28</th>
<th style="text-align: center;">27:12</th>
<th style="text-align: center;">11:1</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">vERSION</td>
<td style="text-align: center;">pARTnUMBER</td>
<td style="text-align: center;">mANUFLD</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table><p><strong>ManufId:</strong> Bits 6:0 must be the bits 6:0 of the design/manufacturer identification code specified by the JEDEC standard JEP106. Bits 10:7 contain the modulo-16 count of the continuation characters (0x7f) in the same identification code.</p>
</section>
<section id="dtm-control-and-status-dtmcs-0x10">
<h5>2.4.5.2.2  DTM Control and Status (dtmcs，0x10)<a class="headerlink" href="#dtm-control-and-status-dtmcs-0x10" title="Link to this heading"></a></h5>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">31:18</th>
<th style="text-align: center;">17</th>
<th style="text-align: center;">16</th>
<th style="text-align: center;">15</th>
<th style="text-align: center;">14:12</th>
<th style="text-align: center;">11:10</th>
<th style="text-align: center;">9:4</th>
<th style="text-align: center;">3:0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">dmihardreset</td>
<td style="text-align: center;">dmireset</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">idle</td>
<td style="text-align: center;">dmistat</td>
<td style="text-align: center;">abits</td>
<td style="text-align: center;">version</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Field</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Access</th>
<th style="text-align: center;">Reset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">dmihardreset</td>
<td style="text-align: center;">Writing a 1 to this bit performs a hard reset on the DTM, causing it to forget any ongoing DMI transactions. This should generally only be used when the debugger has reason to expect that the ongoing DMI transactions will never complete (e.g., reset conditions cause an in-progress DMI transaction to be aborted).</td>
<td style="text-align: center;">W</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">dmireset</td>
<td style="text-align: center;">Writing a 1 to this bit clears the error state and allows the DTM to retry or complete the previous transaction.</td>
<td style="text-align: center;">W</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">idle</td>
<td style="text-align: center;">This is a hint to the debugger regarding the minimum number of cycles it should spend in RunTest/Idle after each DMI scan to avoid returning the 'busy' code (dmistat is 3). The debugger must still check dmistat as necessary.  0: No need to enter Run-Test/Idle.   1: Enter Run-Test/Idle and exit immediately. 2: Enter Run-Test/Idle, stay for 1 cycle, then leave.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">dmistat</td>
<td style="text-align: center;">0: No error. 1: Reserved. Interpretation is the same as for 2. 2: Operation failed (caused by op (2)). 3: Attempted operation while a DMI access is still in progress (caused by op (3)).</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">abits</td>
<td style="text-align: center;">The size of the address in dmi.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">version</td>
<td style="text-align: center;">0: Version described in specification version 0.11. 1: Version described in specification version 0.13. 15: Version not described in any available version of this specification.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table></section>
</section>
<section id="debug-module-interface-access-dmi-0x11">
<h4>2.4.5.3 Debug  Module Interface Access(dmi,0x11)<a class="headerlink" href="#debug-module-interface-access-dmi-0x11" title="Link to this heading"></a></h4>
<p>The Debug Module is subordinate to a bus known as the Debug Module Interface (DMI). The master of this bus is the Debug Transport Module (DTM). The Debug Module Interface can be a simple bus with a master and a slave, or it can utilize a more comprehensive bus, such as TileLink or AMBA Advanced Peripheral Bus. The details are left to the system designer.</p>
<p>DMI uses <strong>7 to 32 address bits</strong>. It supports <strong>read and write</strong> operations. The bottom of the address space is used for the first (often the only) DM. Additional space can be used for custom debug devices, other cores, additional DMs, etc. If there are additional DMs on this DMI, the base address of the next DM in the DMI address space is given in <code class="docutils literal notranslate"><span class="pre">nextdm</span></code>.</p>
<p>The Debug Module is controlled by accessing its DMI address space through registers.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Field</th>
<th style="text-align: left;">Description</th>
<th style="text-align: center;">Access</th>
<th style="text-align: center;">Reset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">address</td>
<td style="text-align: left;">The address used for DMI access. This value is used for accessing the DM via DMI during Update-DR.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">data</td>
<td style="text-align: left;">The data sent to the DM via DMI during Update-DR, and the data returned by the DM after a previous operation.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">op</td>
<td style="text-align: left;">When the debugger writes this byte, the meanings are as follows: 0: Ignore data and address. Do not send anything via DMI during Update-DR. This operation will never result in a busy or error response. The address and data reported by the following Capture-DR are undefined. 1: Read from address. (Read) 2: Write data to address. (Write) 3: Reserved.</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table><p>When the debugger reads this byte, it indicates:<br />0: The previous operation was successfully completed.<br />1: Reserved.<br />2: The previous operation failed. The data scanned into dmi during this access will be ignored. This state is sticky and can be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>. This indicates that the DM itself responded with an error. There is no specific case for a DM to respond with an error, and DMI does not need to support returning an error.<br />3: An operation was attempted while a DMI request was still in progress. The data scanned into dmi during this access will be ignored. This state is sticky and can be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>. If the debugger sees this state, it needs to provide more TCK edges to the target between UpdateDR and Capture-DR. The simplest method is to add extra transitions in Run-Test/Idle.</p>
<p>To read an arbitrary Debug Module register, select dmi, scan a value with <code class="docutils literal notranslate"><span class="pre">op</span></code> set to 1, and set the address to the desired register address. During Update-DR, the operation will start, and the result of the operation will be captured as data during Capture-DR. If the operation does not complete in time, <code class="docutils literal notranslate"><span class="pre">op</span></code> will be 3, and the value in <code class="docutils literal notranslate"><span class="pre">data</span></code> must be ignored. The busy state must be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>, and a second scan must be performed. This process must be repeated until <code class="docutils literal notranslate"><span class="pre">op</span></code> returns 0. In subsequent operations, the debugger should allow more time between Capture-DR and Update-DR.</p>
<p>To write an arbitrary Debug Module register, select dmi, scan a value with <code class="docutils literal notranslate"><span class="pre">op</span></code> set to 2, and set the address and data to the desired register address and data, respectively. From that point on, everything is exactly the same as for a read, except that a write is performed instead of a read.</p>
<p>There is almost no need to scan the IR, thus avoiding most of the inefficiencies in typical JTAG usage.</p>
</section>
<section id="bypass">
<h4>2.4.5.4 BYPASS<a class="headerlink" href="#bypass" title="Link to this heading"></a></h4>
<p>This is an invalid 1-bit register, used when the debugger does not wish to communicate with this TAP. The entire register is read-only.</p>
</section>
<section id="debug-module-control-dmcontrol-0x10">
<h4>2.4.5.5 Debug Module Control (dmcontrol, 0x10)<a class="headerlink" href="#debug-module-control-dmcontrol-0x10" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">31</th>
<th style="text-align: center;">30</th>
<th style="text-align: center;">29</th>
<th style="text-align: center;">28</th>
<th style="text-align: center;">27</th>
<th style="text-align: center;">26</th>
<th style="text-align: center;">25:16</th>
<th style="text-align: center;">15:6</th>
<th style="text-align: center;">5:4</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">haltreq</td>
<td style="text-align: center;">resumereq</td>
<td style="text-align: center;">hartreset</td>
<td style="text-align: center;">ackhavereset</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">hasel</td>
<td style="text-align: center;">hartsello</td>
<td style="text-align: center;">hartselhi</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">setresethaltreq</td>
<td style="text-align: center;">clrresethaltreq</td>
<td style="text-align: center;">ndmreset</td>
<td style="text-align: center;">dmactive</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Field</th>
<th style="text-align: left;">Description</th>
<th style="text-align: center;">Access</th>
<th style="text-align: center;">Reset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">haltreq</td>
<td style="text-align: left;">Writing a 0 clears the halt request bit for all currently selected harts, potentially canceling outstanding halt requests for those harts. Writing a 1 sets the halt request bit for all currently selected harts. Running harts will stop when their halt request bit is set. The write applies to the new values of hartsel and hasel.</td>
<td style="text-align: center;">W</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">resumereq</td>
<td style="text-align: left;">Writing a 1 will cause them to resume once if the currently selected harts are stopped at the time of the write operation. If haltreq is set, resumereq is ignored. The write applies to the new values of hartsel and hasel.</td>
<td style="text-align: center;">W</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">hartreset</td>
<td style="text-align: left;">This optional bit writes the reset bit for all currently selected harts. To perform a reset, the debugger writes a 1, followed by a 0 to cancel the reset signal. While this bit is 1, the debugger cannot change the selected hart. If this feature is not implemented, the bit always remains 0, so the debugger can write 1 and then read the register to see if it is supported.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">ackhavereset</td>
<td style="text-align: left;">0: Invalid. 1: Clears the havereset bit for any selected hart. The write applies to the new values of hartsel and hasel.</td>
<td style="text-align: center;">W1</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">hasel</td>
<td style="text-align: left;">0: There is currently one hart selected by hartsel. 1: There may be multiple harts currently selected, consisting of the hart selected by hartsel, plus any harts selected by the hart mask register.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">hartsello</td>
<td style="text-align: left;">The lower 10 bits of hartsel: The dm-specific index of the hart to be selected. This hart is always part of the currently selected hart.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">hartselhi</td>
<td style="text-align: left;">The upper 10 bits of hartsel: The dm-specific index of the hart to be selected. This hart is always part of the currently selected hart.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">setresethaltreq</td>
<td style="text-align: left;">This optional bit writes the reset halt request bit for all currently selected harts unless clrresethaltreq is set to 1 at the same time. When set to 1, each selected hart will stop on the next reset. The reset request bit does not clear automatically. The debugger must write clrresethaltreq to clear it. The write applies to the new values of hartsel and hasel. hasresethaltreq = 0 indicates that this byte is not implemented.</td>
<td style="text-align: center;">W1</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">clrresethaltreq</td>
<td style="text-align: left;">This optional bit clears the reset request bit for all currently selected harts. The write applies to the new values of hartsel and hasel.</td>
<td style="text-align: center;">W1</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">ndmreset</td>
<td style="text-align: left;">This bit controls the reset signal from the DM to the rest of the system. The signal should reset every part of the system, including each hart, except for the DM and any logic required to access the DM. To perform a system reset, the debugger writes a 1, followed by a 0 to cancel the reset.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">dmactive</td>
<td style="text-align: left;">This bit acts as a reset signal for the debug module itself. 0: The module is in its reset state, including the authentication mechanism, with the exception of dynamic bits, which are the only bits that can be written to something other than their reset value. 1: The module is functioning normally.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table></section>
<section id="debug-module-status-dmstatus-at-0x11">
<h4>2.4.5.6 Debug Module Status (dmstatus, at 0x11)<a class="headerlink" href="#debug-module-status-dmstatus-at-0x11" title="Link to this heading"></a></h4>
<p>This register reports the status of the entire debug module and the currently selected hart as defined in <code class="docutils literal notranslate"><span class="pre">hasel</span></code>. Its address will not change in the future because it contains version information.</p>
<p>The entire register is read-only.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">31:23</th>
<th style="text-align: center;">22</th>
<th style="text-align: center;">21:20</th>
<th style="text-align: center;">19</th>
<th style="text-align: center;">18</th>
<th style="text-align: center;">17</th>
<th style="text-align: center;">16</th>
<th style="text-align: center;">15</th>
<th style="text-align: center;">14</th>
<th style="text-align: center;">13</th>
<th style="text-align: center;">12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">3:0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">impebreak</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">allhavereset</td>
<td style="text-align: center;">anyhavereset</td>
<td style="text-align: center;">allresumeack</td>
<td style="text-align: center;">anyresumeack</td>
<td style="text-align: center;">allnonexistent</td>
<td style="text-align: center;">anynonexistent</td>
<td style="text-align: center;">allunavail</td>
<td style="text-align: center;">anyunavail</td>
<td style="text-align: center;">allrunning</td>
<td style="text-align: center;">anyrunning</td>
<td style="text-align: center;">allhalted</td>
<td style="text-align: center;">anyhalted</td>
<td style="text-align: center;">authenticated</td>
<td style="text-align: center;">authbusy</td>
<td style="text-align: center;">hasresethaltreq</td>
<td style="text-align: center;">confstrptrvalid</td>
<td style="text-align: center;">version</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Field</th>
<th style="text-align: left;">Description</th>
<th style="text-align: center;">Access</th>
<th style="text-align: center;">Reset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">impebreak</td>
<td style="text-align: left;">If set to 1, there is an implicit ebreak instruction at a non-existent word following the program buffer. This allows the debugger to avoid writing ebreak itself and allows the program buffer to be one word shorter. When proprobussize is 1, this value must be 1.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">allhavereset</td>
<td style="text-align: left;">This bit is 1 when all currently selected harts have been reset and the reset has not been acknowledged.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anyhavereset</td>
<td style="text-align: left;">This bit is 1 when at least one currently selected hart has been reset and that hart has not acknowledged the reset.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">allresumeack</td>
<td style="text-align: left;">This bit is 1 when all currently selected harts have acknowledged their last resume request.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anyresumeack</td>
<td style="text-align: left;">This bit is 1 when any currently selected hart has acknowledged its last resume request.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">allnonexistent</td>
<td style="text-align: left;">This bit is 1 when the currently selected harts do not exist in this platform.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anynonexistent</td>
<td style="text-align: left;">This bit is 1 when the currently selected harts do not exist in this platform.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">allunavail</td>
<td style="text-align: left;">This bit is 1 when all currently selected harts are unavailable.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anyunavail</td>
<td style="text-align: left;">This bit is 1 when any currently selected hart is unavailable.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">allrunning</td>
<td style="text-align: left;">This bit is 1 when all currently selected harts are running.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anyrunning</td>
<td style="text-align: left;">This bit is 1 when any currently selected hart is running.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">allhalted</td>
<td style="text-align: left;">This bit is 1 when all currently selected harts are halted.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">anyhalted</td>
<td style="text-align: left;">This bit is 1 when any currently selected hart is halted.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">authenticated</td>
<td style="text-align: left;">0: Authentication is required before using the DM. 1: Authentication check passed.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">authbusy</td>
<td style="text-align: left;">0: The authentication module is ready to process the next read of authdata. 1: The authentication module is busy. Accessing authdata will result in unspecified behavior.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">hasresethaltreq</td>
<td style="text-align: left;">1: If this debug module supports the reset-halt feature controlled by setresethaltreq and clrresethaltreq bits. 0: Otherwise.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">confstrptrvalid</td>
<td style="text-align: left;">0: confstrptr0{confstrptr3 stores information unrelated to the configuration string. 1: confstrptr0{confstrptr3 stores the address of the configuration string.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">version</td>
<td style="text-align: left;">0: No debug module exists. 1: There is a debug module that complies with version 0.11 of this specification. 2: There is a debug module that complies with version 0.13 of this specification. 3: There is a debug module, but it does not comply with any available version of this specification.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
<section id="abstract-control-and-status-abstractcs-at-0x16">
<h4>2.4.5.7 Abstract Control and Status (abstractcs, at 0x16)<a class="headerlink" href="#abstract-control-and-status-abstractcs-at-0x16" title="Link to this heading"></a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">31：29</th>
<th style="text-align: center;">28：24</th>
<th style="text-align: center;">23:13</th>
<th style="text-align: center;">12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10:8</th>
<th style="text-align: center;">7:4</th>
<th style="text-align: center;">3:0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">progbufsize</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">busy</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">cmderr</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">datacount</td>
</tr>
</tbody>
</table><p>Sure, here is the professional English translation of the provided table:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Field</th>
<th style="text-align: left;">Description</th>
<th style="text-align: center;">Access</th>
<th style="text-align: center;">Reset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">progbufsize</td>
<td style="text-align: left;">Size of the program buffer, represented in 32-bit words. Valid sizes range from 0 to 16.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset</td>
</tr>
<tr>
<td style="text-align: center;">busy</td>
<td style="text-align: left;">1: Indicates that an abstract command is currently being executed. This bit is set immediately when the command is written and is cleared only after the command has completed.</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">cmderr</td>
<td style="text-align: left;">Captures if an abstract command fails. The bits in this byte remain unchanged until they are cleared by writing 1 to them. No abstract command will be initiated until this value is reset to 0. This byte contains a valid value only when busy is 0. 0 (none): No error. 1 (busy): An abstract command is being executed when either command, abstractcs, or abstractauto is written, or when one of the data or program registers is read or written. This status can only be written when cmderr contains 0. 2 (not supported): The requested command is not supported, regardless of whether the hart is running or not. 3 (exception): An exception occurred during the execution of the command (e.g., while executing the program buffer). 4 (halt/resume): The abstract command cannot be executed because the hart is not in the required state (running/stopped) or is unavailable. 5 (bus): The abstract command failed due to a bus error (e.g., alignment, access size, or timeout). 7 (other): The command failed for other reasons.</td>
<td style="text-align: center;">R/W1C</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">datacount</td>
<td style="text-align: left;">The number of data registers implemented as part of the abstract command interface. Valid lengths range from 1 to 12.</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">Preset-</td>
</tr>
</tbody>
</table></section>
</section>
<section id="id26">
<h3>2.4.6 Checklist<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
</section>
</section>
<section id="qspi">
<h2>2.5 QSPI<a class="headerlink" href="#qspi" title="Link to this heading"></a></h2>
<section id="qspi-technical-specification">
<h3>2.5.1 QSPI Technical Specification<a class="headerlink" href="#qspi-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-23.png" /></p>
<section id="id27">
<h4>Description<a class="headerlink" href="#id27" title="Link to this heading"></a></h4>
<p>SPI_1 is mounted on the MEISHAV100 as an SPI master, responsible for controlling external SPI data transfers. SPI_1 utilizes the open-source axi-spi-master code, which can be referenced at <a class="reference external" href="https://github.com/pulp-platform/axi_spi_master">https://github.com/pulp-platform/axi_spi_master</a>.</p>
</section>
<section id="id28">
<h4>Features<a class="headerlink" href="#id28" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Primarily designed for serial NOR Flash and ADC devices</p></li>
<li><p>Supports standard SPI, dual SPI, or quad-channel SPI commands</p>
<ul>
<li><p>Signal SD[0] may also be recognized by other</p></li>
<li><p>SPI masters as “MOSI,” while SD[3] is commonly referred to as “MISO”</p></li>
</ul>
</li>
<li><p>Separate FIFOs for RX and TX data</p>
<ul>
<li><p>288-byte capacity for TX data and 256-byte capacity for RX data</p></li>
<li><p>FIFO loading/unloading via 32-bit TL-UL registers</p></li>
<li><p>Supports arbitrary byte counts in each transaction</p></li>
</ul>
</li>
<li><p>SPI clock rate controlled by a separate input clock to the core</p>
<ul>
<li><p>SPI SCK line typically toggles at half the core clock frequency</p></li>
<li><p>An additional clock rate divider is available to reduce the frequency if needed</p></li>
</ul>
</li>
<li><p>Supports all SPI polarities and phases (CPOL, CPHA)</p>
<ul>
<li><p>Additional support for “full-cycle” SPI transactions, where data can be read after an entire SPI clock cycle (as opposed to the typical half cycle in SPI interfaces)</p></li>
</ul>
</li>
<li><p>Single Transfer Rate (STR) only (i.e., receiving data on multiple lines but only sampling data on one clock edge)</p>
<ul>
<li><p>Does not support Dual Transfer Rate (DTR)</p></li>
</ul>
</li>
<li><p>Pass-through mode for coordination with the SPI_DEVICE IP</p></li>
<li><p>Automatic control of the chip select signal line</p></li>
<li><p>Compact interrupt footprint: two lines corresponding to two distinct interrupt classes: “error” and “spi_event”</p>
<ul>
<li><p>Fine-grained interrupt masking provided by an auxiliary enable register</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="id29">
<h3>2.5.2 Theory of Operation<a class="headerlink" href="#id29" title="Link to this heading"></a></h3>
</section>
<section id="qspi-design-verification">
<h3>2.5.3 QSPI Design Verification<a class="headerlink" href="#qspi-design-verification" title="Link to this heading"></a></h3>
<p>Connect <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> to the QSPI on MEISHAV100, and use data sent via <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> to control QSPI for reading and writing memory.</p>
<section id="connecting-spi-1-and-qspi">
<h4>2.5.3.1 Connecting SPI_1 and QSPI<a class="headerlink" href="#connecting-spi-1-and-qspi" title="Link to this heading"></a></h4>
<p>Add the following code to the top-level file <strong>dut_MEISHAV100_TOP_wrapper.sv</strong>:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// spi_1 test</span>

<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_sdo</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_sdo</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_master_sdi</span><span class="w">               </span><span class="o">=</span><span class="w">   </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_sdi</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_clk</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_clk</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_csn</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_csn</span><span class="p">[</span><span class="mh">0</span><span class="p">];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">spi_slave_if</span></code> is a virtual interface added for testing QSPI, used to connect to QSPI. The <code class="docutils literal notranslate"><span class="pre">spi_master</span></code> signal is the <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> signal brought out at the top level.</p>
</section>
<section id="writing-the-test-case">
<h4>2.5.3.2 Writing the Test Case<a class="headerlink" href="#writing-the-test-case" title="Link to this heading"></a></h4>
<p>Follow the structure of other test cases, primarily modifying the content within the <code class="docutils literal notranslate"><span class="pre">main_phase</span></code>:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">tl_agent_pkg</span><span class="o">::</span><span class="n">tl_host_single_seq</span><span class="w"> </span><span class="n">seq</span><span class="p">;</span>
<span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="s">&quot;seq&quot;</span><span class="p">);</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_addr_alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_rand_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_rand_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">override_a_source_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">overridden_a_source_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>

<span class="no">`DV_CHECK_RANDOMIZE_WITH_FATAL</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
<span class="w">  </span><span class="n">size</span><span class="w">             </span><span class="o">==</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">mask</span><span class="w">             </span><span class="o">==</span><span class="w"> </span><span class="mh">&#39;hf</span><span class="p">;</span>
<span class="w">  </span><span class="n">source</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">write</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="p">)</span>

<span class="c1">// Initialize Mode and clock and data length, command and address length, Dummy cycles</span>

<span class="c1">// reset FIFO</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">&#39;h1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">4</span><span class="p">);</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>


<span class="c1">// set clock, spi_clk = axi_clk / (2 * (clk_div + 1))</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_CLKDIV</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="c1">// set data length and command to be 8 bits, address 0 bits</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPILEN</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h8</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h8</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>


<span class="c1">// set write dummy cycles to be 0, read dummy cycles to be 33</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIDUM</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">16&#39;h21</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Select the values for the configuration registers based on whether QSPI transfer is used or not.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// if transmit by qspi mode, need to set reg0 of qspi to 1 </span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">24</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0102</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_TXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">24</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Start sending data from a specific address, and increment the address by 4 after each data transmission.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// set data length and address to be 32 bits, command 8 bits</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPILEN</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h20</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h20</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h8</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="c1">// set initial address and data</span>
<span class="n">rw_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h5003</span><span class="n">_F060</span><span class="p">;</span>
<span class="n">write_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>

<span class="k">repeat</span><span class="p">(</span><span class="mh">2000</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="n">$sformatf</span><span class="p">(</span><span class="s">&quot;spi_1 send data: %h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">write_data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_NONE</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// write data to rw_addr</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0200</span><span class="n">_0000</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIADR</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0108</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0102</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_TXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_data</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">#</span><span class="mh">1000</span><span class="n">ns</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// read data from rw_addr, data will be stored in rxfifo</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0b00</span><span class="n">_0000</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIADR</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0104</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0101</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="p">#</span><span class="mh">1000</span><span class="n">ns</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// read data from spi_1 rxfifo</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_RXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">32&#39;h4</span><span class="p">;</span>
<span class="w">    </span><span class="n">write_data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section id="result-of-test">
<h4>2.5.3.3 Result of Test<a class="headerlink" href="#result-of-test" title="Link to this heading"></a></h4>
<p>Primarily test the address spaces for DDR and IRAM. The testing method involves separately testing the low, middle, and high parts of both address spaces. A portion of addresses in each part are tested. The test results are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Address</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Issue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x8000_0000~0x8000_9C40 (10000 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x9FFF_D1C0~0xA000_130C (10000 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0xBFFF_63C0~0xC000_0000 (10000 addresses)</td>
<td style="text-align: center;">Partial Errors</td>
<td style="text-align: center;">The last three addresses read data as 0. After comparing waveforms and code, it was found to be an issue with the mounted VIP. Setting the working mode of the VIP mounted to <code>spi_1</code> to SLAVE resulted in correct operation.</td>
</tr>
<tr>
<td style="text-align: center;">0x5000_0000~0x5000_1F40 (2000 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x5003_F060~0x5004_0FA0 (2000 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x5007_E0C0~0x5008_0000 (2000 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
<section id="software-testing">
<h4>2.5.3.4 Software Testing<a class="headerlink" href="#software-testing" title="Link to this heading"></a></h4>
<p>Translate the above SystemVerilog test code into C language code for software testing. The C code is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// See LICENSE for license details.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;platform.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spi1.h&quot;</span>

<span class="cp">#define QSPI 1</span>

<span class="cp">#define DEBUG</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;kprintf.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x80000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9FFFF830</span><span class="p">,</span><span class="w"> </span><span class="mh">0xBFFFF060</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50003830</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50007060</span><span class="p">};</span>
<span class="w">  </span>
<span class="w">    </span><span class="n">REG32</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span><span class="w"> </span><span class="n">UART_REG_TXCTRL</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_TXEN</span><span class="p">;</span><span class="w">  </span><span class="c1">// donot delete</span>

<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;Test begin ! @ core: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">read_csr</span><span class="p">(</span><span class="n">mhartid</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// reset fifo</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// set clock, spi_clk = axi_clk / (2 * (clk_div + 1))</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_CLKDIV</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// set data length and command to be 8 bits, address 0 bits</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPILEN</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x08</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">;</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIDUM</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x21</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// enable qspi transmit</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0102</span><span class="p">;</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_TXFIFO</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// set data length and address to be 32 bits, command 8 bits</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPILEN</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// set initial address and data</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;DDR test begin!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;IRAM test begin!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// wait until SPI is idle</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// set write command and address</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x02</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIADR</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// initiate a write operation with select CS0</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0108</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0102</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until tx buffer has available place</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// write data to addr</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_TXFIFO</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until SPI is idle</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// set read command and address</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIADR</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// initiate a write operation with select CS0</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0104</span><span class="p">;</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0101</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until rx buffer has available place</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// read data from rxfifo</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">read_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_RXFIFO</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">read_data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;SPI1_TEST FAIL! at addr: %x, the correct data is: %x, but get: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">read_data</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;SPI1_TEST PASS! at addr: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">);</span>

<span class="w">            </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">0x4</span><span class="p">;</span>
<span class="w">            </span><span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;DDR test end!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;IRAM test end!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;Test end ! @ core: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">read_csr</span><span class="p">(</span><span class="n">mhartid</span><span class="p">));</span>


<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;PASS&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="p">{</span>
<span class="w">        </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;FAIL&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="n">SHUTDOWN_FLAG_STR</span><span class="p">);</span><span class="w">  </span><span class="c1">// donnot delete</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Run the test case <code class="docutils literal notranslate"><span class="pre">soft_base_test.sv</span></code>. Mount the AXI VIP in the <code class="docutils literal notranslate"><span class="pre">initialize</span></code> function of the <code class="docutils literal notranslate"><span class="pre">soft_base_test_cfg</span></code> class to ensure QSPI operates normally.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">foreach</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_sw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ON</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707mig1gb*s_axi_slv*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*u_axi_spi_slave*m_axi_mst*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="c1">// for qspi</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707axi_to_pcie_x1*m_axi_slv*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ONLY_MONITOR</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707axi_to_pcie_x1*s_axi_mst*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ONLY_MONITOR</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span><span class="w"> </span><span class="n">$sformatf</span><span class="p">(</span><span class="s">&quot;set_vip_agent_work_mode for inst_path %s, work_mode %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_DEBUG</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//this.m_axi_agent_cfg[i].if_mode = dv_utils_pkg::Host;  // donnot need add in here</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then, run this test case, compile the above C code into a hex file and load it into the RAM. Run the simulation, and the simulation results are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Address</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Issue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x8000_0000~0x8000_0FA0 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x9FFF_F830~0xA000_07D0 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0xBFFF_F060~0xC000_0000 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x5000_0000~0x5000_0FA0 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x5003_F830~0x5004_07D0 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">0x5007_F060~0x5008_0000 (500 addresses)</td>
<td style="text-align: center;">Correct</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
</section>
<section id="id30">
<h3>2.5.4 Hardware Interfaces<a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Signal</th>
<th style="text-align: center;">Direction</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">spi_clk</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Master Clock</td>
</tr>
<tr>
<td style="text-align: center;">spi_csn0</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Chip Selcet0</td>
</tr>
<tr>
<td style="text-align: center;">spi_csn1</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Chip Selcet1</td>
</tr>
<tr>
<td style="text-align: center;">spi_csn2</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Chip Selcet2</td>
</tr>
<tr>
<td style="text-align: center;">spi_csn3</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Chip Selcet3</td>
</tr>
<tr>
<td style="text-align: center;">spi_mode[1:0]</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">SPI Mode</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdo0</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Output Line0</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdo1</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Output Line1</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdo2</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Output Line2</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdo3</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">Output Line3</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdi0</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">Input Line0</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdi1</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">Input Line1</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdi2</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">Input Line2</td>
</tr>
<tr>
<td style="text-align: center;">spi_sdi3</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">Input Line3</td>
</tr>
</tbody>
</table></section>
<section id="id31">
<h3>2.5.5 Registers<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<p>According to the pulpino documentation, the control registers and related functionalities for SPI_1 are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Offset</th>
<th style="text-align: center;">Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0x00</td>
<td style="text-align: center;">STATUS</td>
</tr>
<tr>
<td style="text-align: center;">0x08</td>
<td style="text-align: center;">CLKDIV</td>
</tr>
<tr>
<td style="text-align: center;">0x10</td>
<td style="text-align: center;">SPICMD</td>
</tr>
<tr>
<td style="text-align: center;">0x18</td>
<td style="text-align: center;">SPIADR</td>
</tr>
<tr>
<td style="text-align: center;">0x20</td>
<td style="text-align: center;">SPILEN</td>
</tr>
<tr>
<td style="text-align: center;">0x28</td>
<td style="text-align: center;">SPIDUM</td>
</tr>
<tr>
<td style="text-align: center;">0x40</td>
<td style="text-align: center;">TXFIFO</td>
</tr>
<tr>
<td style="text-align: center;">0x80</td>
<td style="text-align: center;">RXFIFO</td>
</tr>
</tbody>
</table><section id="status-status-register">
<h4>2.5.5.1 STATUS（Status Register）<a class="headerlink" href="#status-status-register" title="Link to this heading"></a></h4>
<p><strong>Reset Value：0x0000_0000</strong>
<img alt="alt text" src="../_images/38481e84-dde1-44ed-b3ca-65937ab976b5.png" /></p>
<ul class="simple">
<li><p><strong>Bit 11: 8  CS: Chip Select</strong>
Designates the chip select signal to be used for the next transfer.</p></li>
<li><p><strong>Bit 4   SRST: Software Reset</strong>
Clears the FIFO and terminates the ongoing transfer.</p></li>
<li><p><strong>Bit 3   QWR: Quad Write Command</strong>
Executes a write operation in QuadSPI mode.</p></li>
<li><p><strong>Bit 2   QRD: Quad Read Command</strong>
Executes a read operation in QuadSPI mode.</p></li>
<li><p><strong>Bit 1   WR: Write Command</strong>
Executes a write operation in standard SPI mode.</p></li>
<li><p><strong>Bit 0   RD: Read Command</strong>
Executes a read operation in standard SPI mode.</p></li>
</ul>
</section>
<section id="clkdiv-clock-divider">
<h4>2.5.5.2 CLKDIV（Clock Divider）<a class="headerlink" href="#clkdiv-clock-divider" title="Link to this heading"></a></h4>
<p><strong>Reset Value：0x0000_0000</strong>
<img alt="alt text" src="../_images/5327509c-1857-4e83-8258-c9a460d65269.png" /></p>
<ul class="simple">
<li><p><strong>Bit 7:0  CLKDIV: Clock Divider</strong>
The clock divider value, used to divide the SoC clock for SPI transfers. This register should not be modified during a transfer.</p></li>
</ul>
</section>
<section id="spicmd-spi-command">
<h4>2.5.5.3 SPICMD（SPI Command）<a class="headerlink" href="#spicmd-spi-command" title="Link to this heading"></a></h4>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/be818689-11e9-4643-9b37-3969e3aa2e00.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  SPICMD: SPI Command</strong>
When executing a read or write transfer, the SPI command is sent first before any data is read or written. The length of the SPI command can be controlled using the SPILEN register.</p></li>
</ul>
</section>
<section id="spiadr-spi-address">
<h4>2.5.5.4 SPIADR（SPI Address）<a class="headerlink" href="#spiadr-spi-address" title="Link to this heading"></a></h4>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/3f6ab307-a8e4-4258-a1c4-b2b35847373c.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  SPIADR: SPI Address</strong>
When performing a read or write transfer, the SPI command is sent first, followed by the SPI address, before any data is read or written. The length of the SPI address can be controlled using the SPILEN register.</p></li>
</ul>
</section>
<section id="spilen-spi-transfer-length">
<h4>2.5.5.5 SPILEN（SPI Transfer Length）<a class="headerlink" href="#spilen-spi-transfer-length" title="Link to this heading"></a></h4>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/bf22607e-923e-4f6f-8679-bad952a7b315.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:16  DATALEN: SPI Data Length</strong>
The number of bits to be read or written. Note that the SPI command and address are first written to the SPI slave device.</p></li>
<li><p><strong>Bit 13:8  ADDRLEN: SPI Address Length</strong>
The number of bits for the SPI address that should be sent.</p></li>
<li><p><strong>Bit 5:0  SPI Command Length</strong>
The number of bits for the SPI command that should be sent.</p></li>
</ul>
<section id="spidum-spi-dummy-cycles">
<h5>2.5.5.6 SPIDUM（SPI Dummy Cycles）<a class="headerlink" href="#spidum-spi-dummy-cycles" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/fead8b77-1e4c-495d-947c-26f0f200ff17.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:16  DUMMYWR: Write Dummy Cycles</strong>
The number of dummy cycles (no write or read) between sending the SPI command + SPI address and writing data.</p></li>
<li><p><strong>Bit 15:0  DUMMYRD: Read Dummy Cycles</strong>
The number of dummy cycles (no write or read) between sending the SPI command + SPI address and reading data.</p></li>
</ul>
</section>
</section>
<section id="txfifo-spi-transmit-fifo">
<h4>2.5.5.7 TXFIFO (SPI Transmit FIFO)<a class="headerlink" href="#txfifo-spi-transmit-fifo" title="Link to this heading"></a></h4>
<p><strong>Reset Value: 0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/273da941-0aed-463d-b909-8f4df84aa9bb.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  TX: Transmit Data</strong>
Data to be written into the FIFO for transmission.</p></li>
</ul>
</section>
<section id="rxfifo-spi-receive-fifo">
<h4>2.5.5.8 RXFIFO (SPI Receive FIFO)<a class="headerlink" href="#rxfifo-spi-receive-fifo" title="Link to this heading"></a></h4>
<p><strong>Reset Value: 0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/3b08a5ca-6b21-4ab6-8dee-8c326cb5e1f5.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  RX: Receive Data</strong>
Data to be read from the FIFO received during transmission.</p></li>
</ul>
<p>Note: There seems to be a typo in the original text where “Transmit Data” is mentioned for both TX and RX. In the RXFIFO section, it should be “Receive Data” as corrected in the translation.</p>
<section id="id32">
<h5>2.5.6 Checklist<a class="headerlink" href="#id32" title="Link to this heading"></a></h5>
</section>
</section>
</section>
</section>
<section id="sram">
<h2>2.6 SRAM<a class="headerlink" href="#sram" title="Link to this heading"></a></h2>
<section id="sram-controller-technical-specification">
<h3>2.6.1 SRAM Controller Technical Specification<a class="headerlink" href="#sram-controller-technical-specification" title="Link to this heading"></a></h3>
<p><img alt="alt text" src="../_images/image-24.png" /></p>
<section id="id33">
<h4>Description<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
<p>The SRAM controller incorporates the SRAM data and address scrambling device and provides CSRs for requesting the scrambling keys and triggering the hardware initialization feature.
In the SRAM Controller of the hw platform, we added a Scramble module (acting on data and addr) and provided CSRs (used for requesting Scramble keys and triggering hardware initialization).
<a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/theory_of_operation.html">This summary draws reference from the content of the OpenTitan Hard-Ware article.</a>
This is an interpretat**ion of the hw part of the sram_ctrl code.</p>
</section>
<section id="id34">
<h4>Features<a class="headerlink" href="#id34" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Lightweight scrambling mechanism</strong> based on the PRINCE cipher.</p></li>
<li><p>Key request logic for the lightweight memory and address scrambling device.</p></li>
<li><p>Alert sender and checking logic for detecting bus integrity failures.</p></li>
<li><p>LFSR-based memory initialization feature.</p></li>
<li><p>Access controls to allow / disallow code execution from SRAM.</p></li>
<li><p>Security hardening when integrity error has been detected.</p></li>
</ul>
</section>
</section>
<section id="id35">
<h3>2.6.2 Theory of Operation<a class="headerlink" href="#id35" title="Link to this heading"></a></h3>
<p>This section explains how the module controls external IRAM through software analysis.</p>
<div align=center>  <p><img alt="alt text" src="../_images/image-12.png" /></p>
<div>
<div align=left><div>       <p>The main structure is concentrated on the left side of the diagram, with a hardware instance application on the right.</p>
<p>It is mainly divided into the following parts:</p>
<ul class="simple">
<li><p>TL-UL SRAM Adapter;</p></li>
<li><p>LFSR: Used for initialization (mechanism detailed in [1.2. Section](### 1.2. LFSR Initialization Mechanism));</p></li>
<li><p>CSRs;</p></li>
<li><p>Key request.</p></li>
</ul>
<section id="how-the-controller-handles-integrity-errors">
<h4>2.6.2.1 How the Controller handles Integrity Errors<a class="headerlink" href="#how-the-controller-handles-integrity-errors" title="Link to this heading"></a></h4>
<p>When encountering an <strong>Integrity Error</strong>, <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> will latch the integrity error and issue a <code class="docutils literal notranslate"><span class="pre">fatal_bus_integ_error</span></code> until the next reset (the generation of integrity errors is determined by system integration).</p>
<p>Additionally, the latched error condition is fed into the <code class="docutils literal notranslate"><span class="pre">prim_ram_1p_scr</span></code> primitive via a dedicated input, causing the scrambling primitive to perform the following actions:</p>
<ul class="simple">
<li><p>Invert the pseudorandom number used during address and CTR scrambling;</p></li>
<li><p>Disable any transactions (read or write) to the actual memory macro.</p></li>
</ul>
</section>
<section id="lfsr-initialization-mechanism">
<h4>2.6.2.2 LFSR Initialization Mechanism<a class="headerlink" href="#lfsr-initialization-mechanism" title="Link to this heading"></a></h4>
<p>Since the <strong>Scramble device</strong> uses a block cipher in CTR mode, from a security perspective, it is undesirable to initialize the memory to all zeros (this would leak the XOR keystream).</p>
<p>To avoid this, <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> includes an LFSR-based initialization mechanism that overwrites the entire memory with pseudo-random data.</p>
<p>Initialization can be triggered via the <code class="docutils literal notranslate"><span class="pre">CTRL.INIT</span></code> CSR. When initialization is triggered, the LFSR is first re-seeded using the obtained random number and the scrambling key. Then, the pseudo-random data extracted from the LFSR is used to initialize the memory.</p>
<p>For each pseudo-random 32-bit data, the initialization mechanism calculates the corresponding integrity bits and writes the data and integrity bits (a total of 39 bits) through the scrambling device using the most recently obtained scrambling key.</p>
<p>If the Scrambling Key update and LFSR initialization are triggered simultaneously on the software side (i.e., the software uses the same CSR write operation as the LFSR), the LFSR initialization will be halted until the updated Scrambling Key is obtained.</p>
<p>There is no limit on the frequency of calls to the initialization function, so it can also be used at runtime as a cheap SRAM erase mechanism. However, note that the PRNG sequence does not have strong security guarantees, as it is generated using an LFSR.</p>
</section>
<section id="executing-code-via-sram">
<h4>2.6.2.3. Executing Code via SRAM<a class="headerlink" href="#executing-code-via-sram" title="Link to this heading"></a></h4>
<p>The enable signal of the RAM ctrl is controlled by <code class="docutils literal notranslate"><span class="pre">otp_ctrl</span></code>;</p>
<div align=center>  <p><img alt="alt text" src="../_images/image-13.png" /></p>
<div>
<div align=left><div>   </section>
<section id="read-and-write-sequences">
<h4>2.6.2.4. Read and Write Sequences<a class="headerlink" href="#read-and-write-sequences" title="Link to this heading"></a></h4>
<p>Combining the original text, the timing requirements for read and write operations are as follows:</p>
<ul class="simple">
<li><p>For timing reasons, the scrambling primitive instantiates a register in the middle of the PRINCE block cipher;</p></li>
<li><p>Write operations must be delayed by 1 cycle;</p></li>
<li><p>Sub-word write accesses currently require read-modify-write operations to recalculate the integrity bits of the entire word.</p></li>
</ul>
</section>
</section>
<section id="id36">
<h3>2.6.3 Design Verification<a class="headerlink" href="#id36" title="Link to this heading"></a></h3>
<p>The test plan objectives for the SRAM Controller (for dvsim) are as follows:</p>
<ul class="simple">
<li><p>Verify all SRAM_CTRL IP functionalities through dynamic simulations using SV/UVM-based test benches.</p></li>
<li><p>Develop and run all tests according to the test plan to close code and functional coverage for the IP and all its submodules (excluding pre-verified submodules).</p></li>
<li><p>Refer to the <a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/dv/index.html#top-level-testbench">OpenTitan SRAM CTRL test plan</a> for specific test cases.</p></li>
</ul>
<section id="programming-guide">
<h4>Programming Guide<a class="headerlink" href="#programming-guide" title="Link to this heading"></a></h4>
<p>For software-side operational procedures, refer to the <a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/programmers_guide.html">OpenTitan SRAM CTRL software debugging guide</a>.</p>
</section>
</section>
<section id="id37">
<h3>2.6.4 Hardware Interfaces<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<p>This section includes parameters, signals, security signals, and handshake signal behavior with external modules (including OTP and Scramble devices). The <strong>handshake signal behavior with external modules (including OTP and Scramble devices)</strong> is also described in terms of software-side security measures.</p>
</section>
<section id="parameters">
<h3>2.6.4.1 Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">Default</th>
<th style="text-align: center;">Top Earlgrey</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>AlertAsyncOn</code></td>
<td style="text-align: center;">1'b1</td>
<td style="text-align: center;">1'b1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>InstrExec</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Enable execution from SRAM side</td>
</tr>
<tr>
<td style="text-align: center;"><code>MemSizeRam</code></td>
<td style="text-align: center;">4096</td>
<td style="text-align: center;">(multiple values)</td>
<td style="text-align: center;">Number of 32-bit words in SRAM (overridable by topgen)</td>
</tr>
<tr>
<td style="text-align: center;"><code>RndCnstSramKey</code></td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">Random default constant for Scrambling Key at compile time</td>
</tr>
<tr>
<td style="text-align: center;"><code>RndCnstSramNonce</code></td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">Random default constant for Scrambling Nonce at compile time</td>
</tr>
<tr>
<td style="text-align: center;"><code>RndCnstLfsrSeed</code></td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">Random default constant for LFSR seed at compile time</td>
</tr>
<tr>
<td style="text-align: center;"><code>RndCnstLfsrPerm</code></td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">(see RTL)</td>
<td style="text-align: center;">Random default constants for LFSR permutation at compile time</td>
</tr>
</tbody>
</table></section>
<section id="external-signal-interfaces">
<h3>2.6.4.2 External Signal Interfaces<a class="headerlink" href="#external-signal-interfaces" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> module defines the following hardware interfaces:</p>
<ul class="simple">
<li><p>Main clock: <code class="docutils literal notranslate"><span class="pre">clk_i</span></code></p></li>
<li><p>Other clocks (OTP device): <code class="docutils literal notranslate"><span class="pre">clk_otp_i</span></code></p></li>
<li><p>Bus device interface (TL-UL): <code class="docutils literal notranslate"><span class="pre">regs_tl</span></code>, <code class="docutils literal notranslate"><span class="pre">ram_tl</span></code></p></li>
<li><p>Bus host interface (TL-UL): none</p></li>
<li><p>Chip IO peripheral pins: none</p></li>
<li><p>Interrupts: none</p></li>
</ul>
</section>
<section id="internal-signal-interfaces">
<h3>2.6.4.3 Internal Signal Interfaces<a class="headerlink" href="#internal-signal-interfaces" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Port Name</th>
<th style="text-align: center;">Package::Struct</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Act</th>
<th style="text-align: center;">Width</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>sram_otp_key</code></td>
<td style="text-align: center;"><code>otp_ctrl_pkg::sram_otp_key</code></td>
<td style="text-align: center;"><code>req_rsp</code></td>
<td style="text-align: center;"><code>req</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>cfg</code></td>
<td style="text-align: center;"><code>prim_ram_1p_pkg::ram_1p_cfg</code></td>
<td style="text-align: center;"><code>uni</code></td>
<td style="text-align: center;"><code>rcv</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Routine signal cfg</td>
</tr>
<tr>
<td style="text-align: center;"><code>lc_escalate_en</code></td>
<td style="text-align: center;"><code>lc_ctrl_pkg::lc_tx</code></td>
<td style="text-align: center;"><code>uni</code></td>
<td style="text-align: center;"><code>rcv</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Global and local upgrade enable</td>
</tr>
<tr>
<td style="text-align: center;"><code>lc_hw_debug_en</code></td>
<td style="text-align: center;"><code>lc_ctrl_pkg::lc_tx</code></td>
<td style="text-align: center;"><code>uni</code></td>
<td style="text-align: center;"><code>rcv</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>otp_en_sram_ifetch</code></td>
<td style="text-align: center;"><code>prim_mubi_pkg::mubi8</code></td>
<td style="text-align: center;"><code>uni</code></td>
<td style="text-align: center;"><code>rcv</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>regs_tl</code></td>
<td style="text-align: center;"><code>tlul_pkg::tl</code></td>
<td style="text-align: center;"><code>req_rsp</code></td>
<td style="text-align: center;"><code>rsp</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>ram_tl</code></td>
<td style="text-align: center;"><code>tlul_pkg::tl</code></td>
<td style="text-align: center;"><code>req_rsp</code></td>
<td style="text-align: center;"><code>rsp</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
<section id="alert-signals">
<h3>2.6.4.4 Alert Signals<a class="headerlink" href="#alert-signals" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: left;">Alert Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>fatal_error</code></td>
<td style="text-align: left;">Triggered when a fatal TL-UL bus integrity failure or initialization mechanism reaches an invalid state.</td>
</tr>
</tbody>
</table></section>
<section id="safety-measures">
<h3>2.6.4.5 Safety Measures<a class="headerlink" href="#safety-measures" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Countermeasure ID</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.BUS.INTEGRITY</code></td>
<td style="text-align: center;">End-to-end bus integrity scheme.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.CTRL.CONFIG.REGWEN</code></td>
<td style="text-align: center;">SRAM control registers are protected by REGWEN.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.EXEC.CONFIG.REGWEN</code></td>
<td style="text-align: center;">SRAM execution enable register is protected by REGWEN.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.EXEC.CONFIG.MUBI</code></td>
<td style="text-align: center;">SRAM execution enable register is multi-bit encoded.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.EXEC.INTERSIG.MUBI</code></td>
<td style="text-align: center;">SRAM execution enable signal from OTP is multi-bit encoded.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.LC_ESCALATE_EN.INTERSIG.MUBI</code></td>
<td style="text-align: center;">Life cycle escalation enable signal is multi-bit encoded.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.LC_HW_DEBUG_EN.INTERSIG.MUBI</code></td>
<td style="text-align: center;">Life cycle hardware debug enable signal is multi-bit encoded.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.MEM.INTEGRITY</code></td>
<td style="text-align: center;">End-to-end data/memory integrity scheme.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.MEM.SCRAMBLE</code></td>
<td style="text-align: center;">Data is scrambled using a key-reduced round PRINCE cipher in CTR mode.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.ADDR.SCRAMBLE</code></td>
<td style="text-align: center;">Addresses are scrambled using a keyed lightweight permutation/diffusion function.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.INSTR.BUS.LC_GATED</code></td>
<td style="text-align: center;">Prevent code execution from SRAM during non-test lifecycle states.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.RAM_TL_LC_GATE.FSM.SPARSE</code></td>
<td style="text-align: center;">Control FSM within TL-UL gating primitive is sparse encoded.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.KEY.GLOBAL_ESC</code></td>
<td style="text-align: center;">Scrambling key and nonce are reset to fixed values during escalation, and bus transactions to memory are blocked.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.KEY.LOCAL_ESC</code></td>
<td style="text-align: center;">Scrambling key and nonce are reset to fixed values during local escalation due to bus integrity or counter errors, and bus transactions to memory are blocked.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.INIT.CTR.REDUN</code></td>
<td style="text-align: center;">Initialization counter is redundant.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.SCRAMBLE.KEY.SIDELOAD</code></td>
<td style="text-align: center;">Scrambling key is sideloaded from OTP and cannot be read by software.</td>
</tr>
<tr>
<td style="text-align: center;"><code>SRAM_CTRL.TLUL_FIFO.CTR.REDUN</code></td>
<td style="text-align: center;">TL-UL response FIFO pointers are implemented using redundant counters.</td>
</tr>
</tbody>
</table><section id="interface-between-otp-and-sram-scrambling-primitives">
<h4>2.6.4.5.1 Interface between OTP and SRAM Scrambling Primitives<a class="headerlink" href="#interface-between-otp-and-sram-scrambling-primitives" title="Link to this heading"></a></h4>
<div align=center>  <p><img alt="alt text" src="../_images/image-14.png" /></p>
<div>  <div align=left><div>     <ul class="simple">
<li><p>The <strong>key derivation interface within OTP CTRL (i.e., <code class="docutils literal notranslate"><span class="pre">sram_otp_key</span></code>)</strong> follows a simple req/ack handshake protocol.</p>
<ol class="simple">
<li><p>SRAM CTRL requests an updated transient key by asserting <code class="docutils literal notranslate"><span class="pre">sram_otp_key_i.req</span></code>.</p></li>
<li><p>The OTP controller obtains the <code class="docutils literal notranslate"><span class="pre">entropy</span></code> signal from CSRNG (refer to CSRNG in hw) and derives the transient key using the <strong>SRAM_DATA_KEY_SEED</strong> and <strong>PRESENT</strong> scrambling data path (as described in the OTP controller specification).</p></li>
<li><p>The OTP controller returns a new transient key via the response channel (<code class="docutils literal notranslate"><span class="pre">sram_otp_key_o[*]</span></code>, <code class="docutils literal notranslate"><span class="pre">otbn_otp_key_o</span></code>), completing the req/ack handshake.</p></li>
</ol>
</li>
<li><p>The key and nonce are available for use by the scrambling primitives in subsequent cycles. The waveform diagram illustrates this process.</p></li>
<li><p>If key seeds are not configured in OTP, keys are derived from all-zero constants, and the <code class="docutils literal notranslate"><span class="pre">*.seed_valid</span></code> signal is set to 0 in the response. Note that this mechanism requires CSRNG and the entropy distribution network to be operational. If they are not, the key derivation request is blocked.</p></li>
<li><p>The req/ack protocol operates on <code class="docutils literal notranslate"><span class="pre">clk_otp_i</span></code>. SRAM CTRL synchronizes the data through the req/ack handshake primitive <code class="docutils literal notranslate"><span class="pre">prim_sync_reqack.sv</span></code>.</p></li>
</ul>
<div align=center><p><img alt="alt text" src="../_images/image-15.png" /></p>
<div>
<div align=left><div>    </section>
<section id="global-and-local-upgrades">
<h4>2.6.4.5.2 Global and Local Upgrades<a class="headerlink" href="#global-and-local-upgrades" title="Link to this heading"></a></h4>
<p>This section explains the functionality of <code class="docutils literal notranslate"><span class="pre">lc_escalate_en_i</span></code>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lc_escalate_en_i</span></code> signal is responsible for initiating global and local upgrades. When this signal is asserted, it triggers the system to perform necessary actions to upgrade the SRAM Controller and its associated components. This includes updating the scrambling keys, resetting counters, and ensuring the integrity of bus transactions to prevent unauthorized access or errors during the upgrade process. Global upgrades affect the entire system, while local upgrades focus on specific components, ensuring a controlled and secure update mechanism.</p>
</section>
</section>
<section id="register">
<h3>2.6.5 Register<a class="headerlink" href="#register" title="Link to this heading"></a></h3>
<p>Detailed reading of
<a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/registers.html">OpenTitan SRAM CTRL Register Configuration</a>,
here is the basic description.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Offset</th>
<th style="text-align: center;">Length</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>ALERT_TEST</strong></td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Alert Test Register (1 bit for alert)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>STATUS</strong></td>
<td style="text-align: center;">0x4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">SRAM Status Register (6 states; 1-bit thermal)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>EXEC_REGWEN</strong></td>
<td style="text-align: center;">0x8</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Execution Enable Register Lock (EXEC's enable)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>EXEC</strong></td>
<td style="text-align: center;">0xc</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">SRAM Execution Enable (4 bits, related to OTG function)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>CTRL_REGWEN</strong></td>
<td style="text-align: center;">0x10</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Control Register Lock (CTRL's enable)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>CTRL</strong></td>
<td style="text-align: center;">0x14</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">SRAM Control Register (2 bits, related to OTG and LFSR control)</td>
</tr>
<tr>
<td style="text-align: center;">sram_ctrl.<strong>SCR_KEY_ROTATED</strong></td>
<td style="text-align: center;">0x18</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Clearable SRAM Key Request Status (4 bits, related to OTG function)</td>
</tr>
</tbody>
</table></section>
<section id="external-interface-function">
<h3>2.6.6 External Interface Function<a class="headerlink" href="#external-interface-function" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">dif_sram_ctrl.h</span></code></p>
</section>
<section id="id38">
<h3>2.6.7 Checklist<a class="headerlink" href="#id38" title="Link to this heading"></a></h3>
<p>Summary and design plan of the article.
To understand the specific functional implementation of SRAM CTRL, it is necessary to read the <strong>LFSR (CSRs)</strong> and <strong>OTP Controller</strong> sections.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, writer38.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>